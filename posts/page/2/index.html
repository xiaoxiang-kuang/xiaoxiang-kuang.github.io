<!DOCTYPE html>
<html dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark">

<title>主页 | 小象的blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.e24d94cf619e7e6705439036ee43e77f243d24ac89100b59375379bc4d659d87.css" >
  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" ></script>
<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="小象的blog" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">

    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>小象的blog</span>
  </a>
</h2>


















  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/categories/book/">
        书籍笔记
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


  <div class="split-line"></div>
  
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>12</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


 
      </div>
    </aside>

    <div class="book-page">
      <div>
	      <header class="book-header">
          
  <div class="flex align-center justify-between">
   <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
  
  <strong>主页</strong>
</div>


  
    <aside class="hidden clearfix">
      <nav>
        




        








        

  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/categories/book/">
        书籍笔记
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





      </nav>
      <div class="split-line"></div>
      
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>12</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


    </aside>
  
 
        </header>
        
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/">C语言练习</a>
    </h2>
    
  <h5>2023-06-09</h5>



  

  
  <div>
    
      <a href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a>
  </div>
  




    <p><ul>
<li>练习程序。</li>
</ul>
        <a href="/posts/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/">查看更多</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/linux/ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Ext4文件系统</a>
    </h2>
    
  <h5>2023-05-12</h5>



  

  
  <div>
    
      <a href="/tags/linux/">linux</a>
  </div>
  




    <p><ul>
<li>一个ext4文件系统被分割为多个block groups，block groups的大小在<code>sb.s_blocks_per_group</code>块中指定。</li>
<li>默认情况下一个块的大小是4KiB，此时每个block group会包含32768个块，即一个group的大小为128MiB。</li>
<li>ext4中块是最小的分配单位。</li>
<li>ext4文件系统采用小端模式，数值的低字节存储在低地址处，高字节存储在高地址处。比如数“12 34 56 78”，小端存放的形式如下“78 56 34 12”。大端存放的形式为“12 34 56 78”。</li>
<li>一个标准的block group布局如下（并非所有的块都是此布局）：</li>
<li>
  <img src="/img/linux/ext4/1.jpg" alt="" /></li>
<li>centos7下使用dumpe2fs获取到的ext4文件系统的信息</li>
<li>
  <img src="/img/linux/ext4/1.2.jpg" alt="" /></li>
<li>
  <img src="/img/linux/ext4/1.1.jpg" alt="" /></li>
<li>ext4会保留一些inode作为特殊用途，如下：</li>
<li>
  <img src="/img/linux/ext4/2.jpg" alt="" /></li>
</ul>
<h2 id="ext4文件系统">
  ext4文件系统
  <a class="anchor" href="#ext4%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f">#</a>
</h2>
<h3 id="目录">
  目录
  <a class="anchor" href="#%e7%9b%ae%e5%bd%95">#</a>
</h3>
<ul>
<li>目录也是文件，目录有对应的inode和data blocks，目录的data block中存放多个ext4_dir_entry_2，结构如下：</li>
<li>
  <img src="/img/linux/ext4/3.jpg" alt="" /></li>
<li>文件类型可以取的值如下：</li>
<li>
  <img src="/img/linux/ext4/4.jpg" alt="" /></li>
<li>案例
<ul>
<li><code>0D000000</code> <code>1000</code> <code>05</code> <code>01</code>  <code>6673746162</code>  <code>000000</code></li>
<li>第一块表示inode号</li>
<li>第二块表示此结构体长度为0x0010，即16，因为ext4采用小端存放，所以高位在高地址，低位在低地址。</li>
<li>第三块表示文件名为5字节</li>
<li>第四块表示文件类型为普通文件</li>
<li>第五块是文件名，对应fstab，f的ascii是0x66，s的是0x73，t是0x75。</li>
<li>最后一块是填充位，结构体大小必须是最大对其数的整数倍。</li>
</ul>
</li>
</ul>
        <a href="/posts/linux/ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">查看更多</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/PCIe%E6%80%BB%E7%BA%BF%E6%A6%82%E8%BF%B0/">PCIe总线概述</a>
    </h2>
    
  <h5>2023-05-04</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>PCIe总线使用高速差分总线，采用端到端的连接方式，因此在每一条PCIe链路中只能连接两个设备，这两个设备互为数据发送端和数据接收端。</li>
<li>PCIe链路使用“端到端的数据传送方式“，发送端和接收端都存在TX(发送逻辑)和RX（接收逻辑）,结构如下：</li>
<li>
  <img src="/img/book/pcie/5.jpg" alt="图4-1" /></li>
<li>在PCIe总线的物理链路的一个数据通路（lane）中，有两组差分信号，共四根信号线。发送端的TX和接收端的RX使用一组差分信号连接。该链路被称为发送端的发送链路，也是接收端的接收链路。一个PCIe链路可以由多个Lane组成。</li>
<li>告诉差分信号电气规范要求发送端串接一个电容，以进行AC耦合，该电容也被称为AC耦合电容。</li>
<li>PCIe链路使用差分信号进行数据传输，一个差分型号由D+和D-两根信号线组成，信号接收端通过比较这两个信号的差值，判断发送端发送的是逻辑1还是逻辑0。</li>
<li>使用差分信号能有效抑制电磁干扰（EMI），差分信号使用两根信号传送一位数据。</li>
<li>PCIe链路可以由多条Lane组成，目前PCIe支持1、2、4、8、12、16和32个Lane，即x1、x2、x4、x8、x12、x16、x32宽度的PCIe链路。</li>
<li>在PCIe总线中，使用GT(gigatransfer)计算PCIe链路的峰值带宽，计算公式为总线频率x数据位宽x2。</li>
<li>PCIe链路使用串行方式进行数据传输，但在芯片内部，数据总线仍然是并行的，因此PCIe链路接口需要进行串并转换。</li>
<li>PCIe总线物理链路之间的数据传送使用基于时钟的同步传送机制，但物理链路并没有时钟线，PCIe总线的接收端含有时钟恢复模块CDR（Clock Data Recovery），CDR从接收报文提取接收时钟，从而进行同步数据传输。</li>
</ul>
<h2 id="pcie总线使用的信号">
  PCIe总线使用的信号
  <a class="anchor" href="#pcie%e6%80%bb%e7%ba%bf%e4%bd%bf%e7%94%a8%e7%9a%84%e4%bf%a1%e5%8f%b7">#</a>
</h2>
<ul>
<li>PCIe设备使用两种电源信号供电，分为是V<sub>cc</sub>和V<sub>aux</sub>，其额定电压为3.3V。PCIe设备使用的主要逻辑模块使用V<sub>cc</sub>供电，而一些与电源管理相关的逻辑使用V<sub>aux</sub>供电。</li>
<li>在一个处理器系统中，一般最多提供x16的PCIe插槽，并使用PETp0~15、PETn0~15和PERp0~15、PERn0~15共64根信号线组成32对差分信号，其中16对PETXX信号用于发送链路。另外16对PERxx信号用于接收链路。除此之外，PCIe总线还使用了下列辅助信号。
<ol>
<li>PERST#信号：该信号为全局复位信号，由处理器系统提供。当该信号有效时，PCIe设备将进行复位操作。PCIe总线定义了多种复位方式，齐总cold reset和warm reset这两种复位方式的实现和该信号有关。</li>
<li>REFCLK+和REFCLK-信号：
<ul>
<li>在一个处理器系统中，可能含有很多PCIe设备，这些设备可以作为Add-In卡与PCIe插槽连接，也可以作为内置模块，与处理器提供的PCIe链路直接相连。PCIe设备与插槽都具有REFCLK+和REFCLK-信号。</li>
<li>PCIe插槽使用这组信号与处理器系统同步。</li>
<li>当PCIe设备作为Add-In卡连接在PCIe插槽时i，可以直接使用PCIe插槽提供的这组信号，也可以使用独立的参考时钟。</li>
</ul>
</li>
<li>WAKE#信号：当PCIe设备进入休眠状态，主电源已经停止供电时，PCIe设备使用该信号向处理器系统提交唤醒请求，使处理器系统重新为该PCIe设备提供主电源Vcc。WAKE#信号是可选的，产生该信号的硬件逻辑必须使用辅助电源Vaux供电。</li>
<li>SMCLK和SMDAT信号：这两个信号与x86的SMBus（System management bus）有关，SMBus由SMCLK和SMDAT信号组成。</li>
<li>JTAG信号：JTAG是一种国际标准测试协议，主要用于芯片的内部测试。正式产品中一般不暴力JTAG接口。</li>
<li>PRSNT1#和PRSNT2#信号：这两个信号和PCIe设备的热插拔有关。</li>
</ol>
</li>
</ul>
<h2 id="pcie总线的层次结构">
  PCIe总线的层次结构
  <a class="anchor" href="#pcie%e6%80%bb%e7%ba%bf%e7%9a%84%e5%b1%82%e6%ac%a1%e7%bb%93%e6%9e%84">#</a>
</h2>
<ul>
<li>PCIe总线使用了串行连接的方式，并使用数据包（Packet）进行数据传输。</li>
<li>PCIe总线的层次结构如下：</li>
<li>
  <img src="/img/book/pcie/6.jpg" alt="图4-4" /></li>
<li>PCIe总线各个层次都是使用硬件逻辑实现的，在PCIe体系结构中，数据报文首先在设备的核心层（Device Core）中产生，然后经过设备的事务层（Transaction Layer）、数据链路层（Data Link Layer）和物理层（Physical Layer），最终发送出去，接收端的数据也需要通过物理层、数据链路层和事务层，最终到达核心层。</li>
</ul>
<h3 id="事务层">
  事务层
  <a class="anchor" href="#%e4%ba%8b%e5%8a%a1%e5%b1%82">#</a>
</h3>
<ul>
<li>事务层定义了PCIe总线使用总线事务，这些总线事务可以通过Switch等设备传送到其他PCIe设备或者RC。RC也可以使用这些总线事务访问PCIe设备。</li>
<li>事务层接收来自PCIe设备核心层的数据，并将其封装成TLP（transaction layer packet）后，发向数据链路层。事务层还从数据链路层接收数据报文，然后转发到PCIe设备的核心层。</li>
</ul>
<h3 id="数量链路层">
  数量链路层
  <a class="anchor" href="#%e6%95%b0%e9%87%8f%e9%93%be%e8%b7%af%e5%b1%82">#</a>
</h3>
<ul>
<li>数据链路层保证来自发送端事务层的报文可以可靠、完整地发送到接收端的数据链路层，来自事务层的报文再通过数据链路层时，被添加Sequence Number前缀和CRC后缀，数据链路层使用ACK/NAK协议保证报文的可靠传输。</li>
</ul>
<h3 id="物理层">
  物理层
  <a class="anchor" href="#%e7%89%a9%e7%90%86%e5%b1%82">#</a>
</h3>
<ul>
<li>物理层是PCIe总线的最底层，将PCIe设备连在一起。PCIe总线的物理电气特性决定了PCIe链路只能采用端到端的连接方式。PCIe总线的物理层为PCIe设备间的数据通信提供了传送介质，为数据传送提供了可靠的物理环境。</li>
</ul>
<h2 id="pcie链路的扩展">
  PCIe链路的扩展
  <a class="anchor" href="#pcie%e9%93%be%e8%b7%af%e7%9a%84%e6%89%a9%e5%b1%95">#</a>
</h2>
<ul>
<li>PCIe使用端到端的数据传送方式，如果要连接多个设备，PCIe链路必须使用Switch扩展PCIe链路。</li>
<li>Switch由1个上游端口和2~n个下游端口组成。在一个switch中和RC直接或间接相连的端口为上游端口。</li>
<li>在switch中，有两个与端口相关的概念，egress和ingress，egress指的是发送端口，即数据离开switch的使用的端口，ingress端口指数据进入switch的使用的端口。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/PCI%E6%A1%A5%E5%92%8CPCI%E8%AE%BE%E5%A4%87/">PCI桥和PCI设备</a>
    </h2>
    
  <h5>2023-05-04</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><h2 id="pci桥与pci设备的配置空间">
  PCI桥与PCI设备的配置空间
  <a class="anchor" href="#pci%e6%a1%a5%e4%b8%8epci%e8%ae%be%e5%a4%87%e7%9a%84%e9%85%8d%e7%bd%ae%e7%a9%ba%e9%97%b4">#</a>
</h2>
<ul>
<li>每一个PCI设备中（包括PCI桥）都包含一个配置空间。这个配置空间由HOST主桥管理，而PCI桥可以转发来自HOST主桥的配置访问。</li>
<li>PCI设备的ID号由总线号（Bus Number）、设备号（Device Number）和功能号（Function Number）组成。</li>
<li>Bus号在HOST主桥遍历PCI总线树时确定。系统软件使用DFS算法扫描PCI总线树上的所有PCI总线，并依次进行编号。</li>
<li>Function号与PCI设备的具体设计有关。</li>
<li>X86处理器定义了两个I/O端口寄存器，分别为CONFIG_ADDRESS（0xCF8）和CONFIG_DATA（0xCFC），X86处理器使用这两个I/O端口访问PCI设备的配置空间。</li>
<li>PCI agent使用的配置空间如下图所示：</li>
<li>
  <img src="/img/book/pcie/2-9.jpg" alt="图2-9" />
<ul>
<li>（这张图要从右往左看）Vendor ID代表PCI设备的生产厂商，Device ID代表这个厂商生产的具体设备。</li>
<li>Revision ID寄存器记录PCI设备的版本号。</li>
<li>Class Code寄存器记载PCI设备的分类，该寄存器由三个字段组成，分别是Base Class Code、Sub Class Code和Interface，其中Base Class Code将PCI设备分类为显卡、网卡、PCI桥等设备。当Base Class Code是0X06，Sub class code是0x04、interface寄存器为0x00时，表示当前的PCI设备是一个桥。</li>
<li>Header Type寄存器，第7位为1表示当前PCI设备是多Function设备，为0表示当前PCI设备是单Function设备，第0~6位表示当前PCI设备的类型，为0表示该设备使用PCI Agent设备的配置空间，为1表示使用PCI桥的配置空间。</li>
<li>Subsystem ID和Subsystem Vendor ID：用于区分设备，有些通过4个ID可以确定一个设备。</li>
<li>Expansion ROM base address寄存器：存放Option ROM程序的基地址。</li>
<li>Capabilities Pointer寄存器：该寄存器存放Capabilities寄存器组的基地址，所有的PCIe设备都要支持Power Management Capability结构和PCI Express Capability结构，所以通过改指针可以找到这两个capability的位置。</li>
<li>BAR寄存器保存PCI设备使用的地址空间的基地址。其中每一个设备最多可以有6个基地址空间。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>PCI 桥的配置空间如下（图2-10）</li>
<li>
  <img src="/img/book/pcie/2-10.jpg" alt="图2-10" /></li>
<li>PCI桥中只有两组BAR寄存器，这两组寄存器是可选的。如果PCI桥中不存在私有寄存器，可以不使用这两组寄存器设置BAR空间。</li>
<li>Primary Bus寄存器保存上游的PCI总线号，Subordinate Bus寄存器存放当前PCI子树中编号最大的PCI总线树，Secondary Bus寄存器存放当前PCI桥使用的总线号。一个PCI桥管理的PCI总线号在Secondary Bus ~ Subordinate Bus之间。这两个寄存器的值由系统软件遍历PCI总线树时设置。</li>
<li>I/O Limit和I/O Base寄存器：存放PCI子树中所有PCI设备使用的I/O地址空间的基地址和大小。</li>
<li>MemoryLimit和Memory Base寄存器：存放PCI子树中PCI设备使用的MMIO基址和大小。</li>
<li>Prefetchable Memory Limit和Prefetchable Memory Base：存放PCI子树中PCI设备使用的可预取MMIO基址和大小。</li>
<li>I/O Base Upper 16 Bits和I/O Limit Upper 16寄存器：如果PCI桥支持32位I/O端口，这组寄存器提供I/O端口的高16位地址。</li>
</ul>
<h2 id="读取slot-capabilities">
  读取slot capabilities
  <a class="anchor" href="#%e8%af%bb%e5%8f%96slot-capabilities">#</a>
</h2>
<ul>
<li>ep设备的SLOT号位于上一级桥的slot capabilities中，slot capabilities位于PCI Express Capability Structure中。PCI Express Capability Structure结构如下图，其Cap ID为0x10。</li>
<li>
  <img src="/img/bios/pcie/3.jpg" alt="" /></li>
<li>slot号位于slot capabilities的19~31位。</li>
<li>
  <img src="/img/bios/pcie/4.jpg" alt="" /></li>
</ul>
<h3 id="案例">
  案例
  <a class="anchor" href="#%e6%a1%88%e4%be%8b">#</a>
</h3>
<ul>
<li>下图硬盘的BDF为86:00.0，槽位号为37</li>
<li>
  <img src="/img/bios/pcie/5.jpg" alt="" /></li>
<li>
  <img src="/img/bios/pcie/6.jpg" alt="" /></li>
<li>其上一级桥的slot capabilities位置如下图，<code>01 28 00 60</code>转换为二进制为<code>0000 0001 0010 1000 0000 0000 0110 0000</code>，其中31~19位为<code>0000 0001 0010 1</code>,将此二进制转为16进制为37。</li>
<li>
  <img src="/img/bios/pcie/7.jpg" alt="" /></li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/protocol/">Protocol</a>
    </h2>
    
  <h5>2023-04-15</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>Protocol是UEFI提供的接口函数。</li>
<li>每个Protocol都包含GUID、Protocol接口的结构体、和Protocol接口函数（Protocol服务）。</li>
<li>3个使用Protocol的函数OpenProtocol、HandleProtocol、LocateProtocol找到Protocol。</li>
<li>.efi文件（如EFI_DRIVER）加载到内存后被称为Image，ImageHandle是Image的句柄。一般模块的入口函数会有一个ImageHandle入参，该参数指向了内存中的Image。</li>
<li>UEFI扫描总线后，会为每个设备建立一个ControllerHandle句柄。即ControllerHandle指向了某个硬件。</li>
<li>每个Handle（对应的结构体为IHANDLE）都会有一个Protocols链表，存放自己的Protocol。所有的IHANDLE通过AllHandles链接起来。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  UINTN         Signature;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/// All handles list of IHANDLE
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LIST_ENTRY    AllHandles;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/// List of PROTOCOL_INTERFACE&#39;s for this handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  LIST_ENTRY    Protocols;
</span></span><span style="display:flex;"><span>  UINTN         LocateRequest;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">/// The Handle Database Key value when this handle was last created or modified
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT64        Key;
</span></span><span style="display:flex;"><span>} IHANDLE;
</span></span></code></pre></div><h2 id="openprotocol">
  OpenProtocol()
  <a class="anchor" href="#openprotocol">#</a>
</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_OPEN_PROTOCOL)(
</span></span><span style="display:flex;"><span>  IN  EFI_HANDLE                Handle, <span style="color:#75715e">//安装了此Protocol的Handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_GUID                  <span style="color:#f92672">*</span>Protocol,  <span style="color:#75715e">//要打开的Protocol的GUID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT VOID                      <span style="color:#f92672">**</span>Interface  OPTIONAL,  <span style="color:#75715e">//返回打开的Protocol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_HANDLE                AgentHandle,    <span style="color:#75715e">//使用此Protocol的Image（存疑）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_HANDLE                ControllerHandle, <span style="color:#75715e">//如果打开的是Protocol是符合UEFI驱动模型的驱动，则此参数为控制Protocol接口的控制器，否则为可选的，可能为NULL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  UINT32                    Attributes  <span style="color:#75715e">//打开Protocol的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><ul>
<li>对于符合UEFI驱动模型的UEFI驱动而言，ControllerHandle是拥有该驱动的控制器，AgentHandle是拥有该EFI_DRIVER_BINGDING_PROTOCOL实例的句柄；</li>
<li>对于UEFI应用而言，ControllerHandle可以忽略，AgentHandle是该程序的句柄，即UefiMain函数的第一个参数。</li>
</ul>
<h2 id="handleprotocol">
  HandleProtocol()
  <a class="anchor" href="#handleprotocol">#</a>
</h2>
<ul>
<li>HandleProtocol不需要提供AgentHandle、ControllerHandle和Attributes。</li>
<li>HandleProtocol的AgentHandle为gDxeCoreImageHandle，ControllerHandle为NULL，Attributes为EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           成功返回指定的Protocol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_UNSUPPORTED       此Handle没有安装此Protocol
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_HANDLE_PROTOCOL)(
</span></span><span style="display:flex;"><span>  IN  EFI_HANDLE               Handle,  <span style="color:#75715e">//安装了此Protocol的Handle
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_GUID                 <span style="color:#f92672">*</span>Protocol,   <span style="color:#75715e">//此Protocol的GUID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT VOID                     <span style="color:#f92672">**</span>Interface  <span style="color:#75715e">//返回此Protocol的实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><h2 id="locateprotocol">
  LocateProtocol()
  <a class="anchor" href="#locateprotocol">#</a>
</h2>
<ul>
<li>当仅有一个Handle安装了某个Protocol时，可以使用LocateProtocol，该函数不需要提供安装了该Protocol的Handle。</li>
<li>如果多个Handle都安装了某个Protocol，就会顺序遍历HANDLE链表，找到第一个该Protocol实例。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_LOCATE_PROTOCOL)(
</span></span><span style="display:flex;"><span>  IN  EFI_GUID  <span style="color:#f92672">*</span>Protocol,  <span style="color:#75715e">//此Protocol的GUID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  VOID      <span style="color:#f92672">*</span>Registration  OPTIONAL,    <span style="color:#75715e">//不知道干啥用的，描述时从RegisterProtocolNotify()获得的key
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT VOID      <span style="color:#f92672">**</span>Interface <span style="color:#75715e">//返回此Protocol的实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><h2 id="efi-driver-binding-protocol">
  EFI Driver Binding Protocol
  <a class="anchor" href="#efi-driver-binding-protocol">#</a>
</h2>
<ul>
<li>从功能上划分，UEFI驱动分为以下类别：
<ul>
<li>符合UEFI驱动模型的驱动（UEFI Driver Model）：包括总线驱动（Bus Drivers）、设备驱动（Device Drivers）和混合驱动（Hybrid Drivers），一般用来驱动对应的硬件设备。</li>
<li>服务型驱动（Service Drivers）：这类驱动不管理任何设备，一般用来产生Protocol。</li>
<li>初始化驱动（Initializing Drivers）：不会产生任何句柄，也不会增加任何Protocol到系统数据库，主要用来初始化一些操作，执行完后就从系统内存中卸载。</li>
<li>根桥型驱动（Root Bridge Drivers）：用来初始化平台上的根桥控制器，并产生一个设备地址Protocol，以及访问总线设备的Protocol，一般用来通过总线驱动访问设备。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>一个完整的符合UEFI驱动模型的驱动程序，大致可分为EFI Driver Binding Protocol和驱动本身提供的服务。前者用来管理驱动，后者才是用户需要使用提供的部分。</li>
<li>所提供的服务一般为多个Protocol。</li>
<li>为了方便用户使用，驱动程序一般还会包括EFI Component Name Protocol，这个Protocol用来显示驱动信息。</li>
<li>EFI_DRIVER_BINDING_PROTOCOL的结构体如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> _EFI_DRIVER_BINDING_PROTOCOL {
</span></span><span style="display:flex;"><span>  EFI_DRIVER_BINDING_SUPPORTED    Supported;  <span style="color:#75715e">//检查设备控制器是否支持驱动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  EFI_DRIVER_BINDING_START        Start;  <span style="color:#75715e">//安装驱动并启动设备
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  EFI_DRIVER_BINDING_STOP         Stop; <span style="color:#75715e">//停止设备并卸载驱动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT32        Version;  <span style="color:#75715e">//版本
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  EFI_HANDLE    ImageHandle;  <span style="color:#75715e">//镜像句柄
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  EFI_HANDLE    DriverBindingHandle;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>接口变量ImageHandle是产生此Protocol实例的镜像句柄，DriverBindingHandle是安装了Protocol实例的句柄。</li>
</ul>
<h3 id="supported接口函数">
  Supported()接口函数
  <a class="anchor" href="#supported%e6%8e%a5%e5%8f%a3%e5%87%bd%e6%95%b0">#</a>
</h3>
<ul>
<li>Supported()接口函数用来检测给定的设备控制器是否支持某驱动，函数原型如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_DRIVER_BINDING_SUPPORTED)(
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//Protocol实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN EFI_DRIVER_BINDING_PROTOCOL            <span style="color:#f92672">*</span>This,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//设备控制器句柄
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN EFI_HANDLE                             ControllerHandle,
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">//此参数对设备型驱动无效
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN EFI_DEVICE_PATH_PROTOCOL               <span style="color:#f92672">*</span>RemainingDevicePath OPTIONAL
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><h3 id="start接口函数">
  Start()接口函数
  <a class="anchor" href="#start%e6%8e%a5%e5%8f%a3%e5%87%bd%e6%95%b0">#</a>
</h3>
<ul>
<li>用来将驱动安装到设备上，并启动硬件设备。一般在此函数中使用InstallProtocolInterface()或InstallMultipleProtocolInterface()函数进行安装。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_DRIVER_BINDING_START)(
</span></span><span style="display:flex;"><span>  IN EFI_DRIVER_BINDING_PROTOCOL            <span style="color:#f92672">*</span>This,
</span></span><span style="display:flex;"><span>  IN EFI_HANDLE                             ControllerHandle,
</span></span><span style="display:flex;"><span>  IN EFI_DEVICE_PATH_PROTOCOL               <span style="color:#f92672">*</span>RemainingDevicePath OPTIONAL
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><h3 id="stop接口函数">
  Stop()接口函数
  <a class="anchor" href="#stop%e6%8e%a5%e5%8f%a3%e5%87%bd%e6%95%b0">#</a>
</h3>
<ul>
<li>用于停止硬件设备，并卸载驱动。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_DRIVER_BINDING_STOP)(
</span></span><span style="display:flex;"><span>  IN EFI_DRIVER_BINDING_PROTOCOL            <span style="color:#f92672">*</span>This,  <span style="color:#75715e">//Protocol实例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_HANDLE                            ControllerHandle, <span style="color:#75715e">//停止此控制器句柄上对应的驱动
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  UINTN                                 NumberOfChildren, <span style="color:#75715e">//子控制器数量
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_HANDLE                            <span style="color:#f92672">*</span>ChildHandleBuffer OPTIONAL <span style="color:#75715e">//子控制器数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><h2 id="efi-component-name-protocol">
  EFI Component Name Protocol
  <a class="anchor" href="#efi-component-name-protocol">#</a>
</h2>
<ul>
<li>为了方便用户使用，UEFI驱动通常会提供名字，以便向用户显示驱动信息。</li>
<li>此功能由EFI_COMPONENT_NAME_PROTOCOL和EFI_COMPONENT_NAME2_PROTOCOL实现，这两种Protocol的功能相同，结构体相同，仅语言代码的格式不同，前者使用的是ISO 639-2语言代码，后者使用的是RFC4646语言代码。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/UEFI%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%87%E4%BB%B6/">UEFI的不同文件</a>
    </h2>
    
  <h5>2023-04-15</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>模块（module）是UEFI上最小的可单独编译的代码单元，它包含INF文件，源代码和二进制文件。INF文件用来描述文件的行为。</li>
<li>包（package）是由模块、平台描述文件（DSC）和包声明文件（DEC）组成，可以不包含模块，也可以包含多个模块。</li>
<li>EDK2中定义了很多类型的模块：
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>BASE</td>
<td>常用于库模块的开发</td>
</tr>
<tr>
<td>SEC</td>
<td></td>
</tr>
<tr>
<td>PEI_CORE</td>
<td></td>
</tr>
<tr>
<td>DXE_CORE</td>
<td></td>
</tr>
<tr>
<td>DXE_DRIVER</td>
<td></td>
</tr>
<tr>
<td>DXE_RUNTIME_DRIVER</td>
<td></td>
</tr>
<tr>
<td>DXE_SAL_DRIVER</td>
<td></td>
</tr>
<tr>
<td>DXE_SMM_DRIVER</td>
<td></td>
</tr>
<tr>
<td>UEFI_DRIVER</td>
<td>UEFI启动模块</td>
</tr>
<tr>
<td>UEFI_APPLICATION</td>
<td>UEFI应用模块</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="搭建uefi工程模块">
  搭建UEFI工程模块
  <a class="anchor" href="#%e6%90%ad%e5%bb%bauefi%e5%b7%a5%e7%a8%8b%e6%a8%a1%e5%9d%97">#</a>
</h2>
<ul>
<li>UEFI编译过程如下：</li>
<li>
  <img src="/img/book/uefi_lb/1.jpg" alt="" /></li>
</ul>
<h3 id="dsc文件">
  DSC文件
  <a class="anchor" href="#dsc%e6%96%87%e4%bb%b6">#</a>
</h3>
<ul>
<li>dsc文件（description）是平台描述文件，描述了模块、库和组件如何编译。文件中还包含很多的节标志如<code>[Defines]</code>。</li>
<li>在dsc文件中，经常用<code>！include</code>来包含其他文件，用<code>#</code>来表示注释。</li>
<li><code>[Defines]</code>中定义了各种变量，必须是dsc文件中的第一个。语法格式如下：</li>
</ul>
<pre tabindex="0"><code class="language-dsc" data-lang="dsc">[Defines]
  PLATFORM_NAME                  = MdeModule
  PLATFORM_GUID                  = 587CE499-6CBE-43cd-94E2-186218569478
  PLATFORM_VERSION               = 0.98
  DSC_SPECIFICATION              = 0x00010005
  #可选
  OUTPUT_DIRECTORY               = Build/MdeModule
  SUPPORTED_ARCHITECTURES        = IA32|X64|EBC|ARM|AARCH64|RISCV64|LOONGARCH64
  BUILD_TARGETS                  = DEBUG|RELEASE|NOOPT
  SKUID_IDENTIFIER               = DEFAULT
</code></pre><ul>
<li>
<p><code>[BuildOptions]</code>中给出编译器和相关的编译参数。</p>
</li>
<li>
<p><code>[LibraryClasses]</code>用来提供模块所使用的库入口，格式如下：</p>
</li>
</ul>
<pre tabindex="0"><code>[LibraryClasses]
  PeiCoreEntryPoint|MdePkg/Library/PeiCoreEntryPoint/PeiCoreEntryPoint.inf
  PeimEntryPoint|MdePkg/Library/PeimEntryPoint/PeimEntryPoint.inf
</code></pre><ul>
<li><code>[Components]</code>用来定义模块编译，指定模块的INF文件所在的位置。格式如下：</li>
</ul>
<pre tabindex="0"><code>[Components]
  MdeModulePkg/Application/HelloWorld/HelloWorld.inf
  MdeModulePkg/Application/DumpDynPcd/DumpDynPcd.inf
  
  #这种格式下，{}内的内容只对当前的INF文件有效
  AppPkg/Applications/LibSample/MyLibApp/MyLibApp.inf{
    &lt;LibraryClasses&gt;
    MyLibraryLib|AppPkg/Applications/LibSample/MyLibrary/MyLibrary.inf
  }
</code></pre><h3 id="inf文件">
  INF文件
  <a class="anchor" href="#inf%e6%96%87%e4%bb%b6">#</a>
</h3>
<ul>
<li>
<p>inf文件是模块的工程文件，描述了模块的属性，如模块由哪些代码组成、依赖了哪些库等。</p>
</li>
<li>
<p>EDK2的模块一般位于包的子目录下，如果是提供库的模块一般位于Library子目录下，如果是UEFI Application，一般位于Application下。</p>
</li>
<li>
<p>INF文件包含很多节标志，包括<code>[Defines]</code>、<code>[Sources]</code>等。</p>
</li>
<li>
<p><code>[Defines]</code>中定义了各种变量，后续编译步骤中需要使用这些变量。</p>
</li>
</ul>
<pre tabindex="0"><code>[Defines]
  INF_VERSION                    = 0x00010005
  BASE_NAME                      = Uefi_Main
  FILE_GUID                      = 6937936E-ED34-44ab-AE97-1FA5E7ED2116
  MODULE_TYPE                    = UEFI_APPLICATION
  VERSION_STRING                 = 1.0
  ENTRY_POINT                    = UefiMain
</code></pre><ul>
<li><code>[Sources]</code>用于列出模块中所有的源文件和资源文件，这些文件位于inf所在的目录或者子目录中。</li>
</ul>
<pre tabindex="0"><code>[Sources]
  Uefi_Main.c
</code></pre><ul>
<li><code>[BuildOptions]</code>和dsc文件的<code>[BuildOptions]</code>语法格式基本相同，INF文件只对本模块有效，DSC对包下所有模块有效。</li>
<li><code>[Protocols]</code>列出了模块时用到的协议，在INF文件中列出的是协议的GUID。</li>
</ul>
<pre tabindex="0"><code>[Protocols]
  gEfiSimpleTextInputExProtocolGuid
  gEfiGraphicsOutputProtocolGuid
</code></pre><ul>
<li><code>LibraryClasses</code>列出本模块需要链接的库。模块如果需要添加库，一般需要：
<ol>
<li>在INF文件下的<code>[LibraryClasses]</code>中添加库名</li>
<li>在DES文件的<code>[LibraryClasses]</code>中寻找这个库，如果没有，则需要添加编译此库的INF文件。</li>
</ol>
</li>
</ul>
<pre tabindex="0"><code>[LibraryClasses]
  UefiLib
  ShellCEntryLib
</code></pre><ul>
<li><code>[Packages]</code>列出本模块引用的所有包的DEC文件。</li>
</ul>
<pre tabindex="0"><code>[Packages]
  MdePkg/MdePkg.dec
  ShellPkg/ShellPkg.dec
</code></pre><h3 id="3种入口函数的uefi应用">
  3种入口函数的UEFI应用
  <a class="anchor" href="#3%e7%a7%8d%e5%85%a5%e5%8f%a3%e5%87%bd%e6%95%b0%e7%9a%84uefi%e5%ba%94%e7%94%a8">#</a>
</h3>
<ul>
<li>
<p><code>&lt;Uefi.h&gt;</code> 定义了UEFI中的基本数据类型和核心数据结构。</p>
</li>
<li>
<p><code>&lt;Library/UefiLib.h&gt;</code>提供通用的库函数。</p>
</li>
<li>
<p><code>&lt;Library/BaseLib.h&gt;</code>提供字符串处理、数学、文件路径处理等相关库函数。</p>
</li>
<li>
<p><code>&lt;Library/BaseMemoryLib.h&gt;</code> 处理内存的库函数。</p>
</li>
<li>
<p><code>&lt;Library/DebugLib.h&gt;</code>功能调试输出的库函数。</p>
</li>
<li>
<p>ImageHandle指向了模块自身加载到内存的Image对象。SystemTable是UEFI应用和UEFI内核交互的桥梁，通过它可以获得UEFI提供的各种服务，包括BS服务和CS服务。</p>
</li>
<li>
<p>在EFI_SYSTEM_TABLE的结构体中，提供了访问BS服务和RT服务的指针。针对一些常用的Protocol的接口，如ConsoleIn（键盘）和ConsoleOut（屏幕）也提供了访问指针。</p>
</li>
</ul>
<h4 id="fdf文件">
  FDF文件
  <a class="anchor" href="#fdf%e6%96%87%e4%bb%b6">#</a>
</h4>
<ul>
<li>Flash Description File FDF文件用来描述固件在Flash中的布局和位置。</li>
<li>一般来说，生成固件的源码中只有一个FDF文件，其作用是规定把哪些包编入Flash中，并确定编译的位置。</li>
<li>FDF文件由<code>[Defines] [FD] [FV] [Capsule] [VTF] [Rule] [OptionRom]</code>等几个节组成。</li>
</ul>
<ol>
<li>[Defines]</li>
<li>[FD]
<ul>
<li>Firmware Device 即固件设备，常用的BIOS ROM就是一个FD。</li>
</ul>
</li>
<li>[FV]
<ul>
<li>Fireware Volume FV是固件的逻辑区域，相当于FD上的分区。这个节定义了镜像包含的组件和模块。</li>
</ul>
</li>
</ol>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/UEFI%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/">UEFI启动流程</a>
    </h2>
    
  <h5>2023-03-17</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><h2 id="bios在计算机系统中的作用">
  BIOS在计算机系统中的作用
  <a class="anchor" href="#bios%e5%9c%a8%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%b3%bb%e7%bb%9f%e4%b8%ad%e7%9a%84%e4%bd%9c%e7%94%a8">#</a>
</h2>
<ul>
<li>BIOS全称为基本输入输出系统，时存储在主板ROM中的一组程序代码，包括：
<ul>
<li>加电自检程序，用于开机时对硬件的检测。</li>
<li>系统初始化代码，包括硬件设备的初始化等。</li>
<li>基本的外围I/O处理的子程序代码。</li>
<li>CMOS设置程序。</li>
</ul>
</li>
</ul>
<h2 id="uefi系统组成">
  UEFI系统组成
  <a class="anchor" href="#uefi%e7%b3%bb%e7%bb%9f%e7%bb%84%e6%88%90">#</a>
</h2>
<ul>
<li>UEFI提供给操作系统的接口包括启动服务（Boot Services，BS）和运行时服务（Runtime Service，RT）以及丰富的Protocol。</li>
<li>从OS Loader被加载，到OS Loader执行ExitBootServices这段时间内，是从UEFI环境向操作系统过渡的过程。这个过程中，OS Loader通过BS和RT使用UEFI提供的服务，将计算机系统资源逐渐转移到自己手中，这个过程称为TSL。</li>
<li>当OS Loader完全掌握了计算机系统资源时，BS也完成了使命。OS Loader调用ExitBootServices结束BS并回收BS占用的资源，之后计算机系统进入UEFI Runtime阶段。</li>
<li>在Runtime阶段只有RT继续为OS提供服务，BS已经从计算机系统中销毁。</li>
</ul>
<hr>
<ul>
<li>UEFI Images 包含可执行代码的二进制文件。</li>
<li>UEFI Services 是平台调用接口的集合，允许UEFI程序和操作系统调用。</li>
<li>UEFI Protocol 是一种数据结构，包含全局唯一标识符GUID、接口数据结构和服务。</li>
<li>UEFI System Table 所有UEFI镜像都会接到一个指向UEFI系统表的指针，通过它可以访问固件提供的UEFI Protocol。</li>
<li>启动服务提供的服务项包括：
<ul>
<li>Event服务：允许程序进行异步操作。</li>
<li>Timer（定时器）服务：配合Event提供定时器的功能。</li>
<li>内存管理：提供内存的分配和释放服务，管理系统的内存映射。</li>
<li>Protocol服务：</li>
<li>Image服务：</li>
<li>其他服务：</li>
</ul>
</li>
<li>运行时服务提供的服务项包括：
<ul>
<li>系统变量服务：读取或设置系统变量。</li>
<li>时间服务：提供读取和设定系统时间的功能。</li>
<li>内存虚拟地址服务：提供将内存的物理地址转换为虚拟地址的服务。</li>
<li>其他服务：如重启系统、更新BIOS等。</li>
</ul>
</li>
</ul>
<h2 id="uefi系统的启动过程">
  UEFI系统的启动过程
  <a class="anchor" href="#uefi%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b">#</a>
</h2>
<ul>
<li>
  <img src="/img/book/uefi/1.jpg" alt="" /></li>
</ul>
<h3 id="1-sec阶段security-phase">
  1. SEC阶段(Security Phase)
  <a class="anchor" href="#1-sec%e9%98%b6%e6%ae%b5security-phase">#</a>
</h3>
<ul>
<li>UEFI系统开机或重启进入SEC阶段，它执行以下四种任务：
<ul>
<li>接收并处理系统启动和重启信号。</li>
<li>初始化临时存储区域：系统运行在SEC阶段时，仅CPU初始化，各种外部设备和内存都没有被初始化，因此系统需要一些临时的RAM区域。 临时RAM只能位于CPU内部。</li>
<li>作为可信系统的根：作为取得对系统控制权的第一部分，SEC阶段是整个可信系统的根。</li>
<li>传递系统参数给下一阶段：SEC阶段的一切工作都是为PEI阶段准备，最终将控制权交给PEI，同时要将现阶段的成果汇报给PEI。汇报的手段是将如下信息作为参数传递到PEI的入口函数。
<ul>
<li>系统当前状态。</li>
<li>可启动固件的地址和大小。</li>
<li>临时RAM区域的地址和大小。</li>
<li>栈的地址和大小。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-pei阶段pre-efi-initialization">
  2. PEI阶段(Pre-EFI Initialization)
  <a class="anchor" href="#2-pei%e9%98%b6%e6%ae%b5pre-efi-initialization">#</a>
</h3>
<ul>
<li>PEI主要是为DXE准备执行环境，PEI的执行流程如下：</li>
<li>
  <img src="/img/book/uefi/2.jpg" alt="" /></li>
<li>从功能上来讲，PEI可以分为：
<ul>
<li>PEI内核（PEI Foundation）：负责PEI基础服务和流程。</li>
<li>PEIM（PEI Module）派遣器：找到系统中所有的PEI模块，并根据依赖关系按顺序执行PEIM。PEI阶段对系统的初始化主要是由PEIM完成的。</li>
</ul>
</li>
<li>PEIM之间的通信是通过PPI（PEIM-to-PEIM Interfaces）完成。</li>
<li>在PEI阶段会初始化内存。</li>
</ul>
<h3 id="3-dxe阶段drier-execution-environment">
  3. DXE阶段(Drier Execution Environment)
  <a class="anchor" href="#3-dxe%e9%98%b6%e6%ae%b5drier-execution-environment">#</a>
</h3>
<ul>
<li>DXE阶段内存可以完全被使用，DXE执行阶段的流程如下：</li>
<li>
  <img src="/img/book/uefi/3.jpg" alt="" /></li>
<li>DXE从功能上可以分为以下两部分：
<ul>
<li>DXE内核：负责DXE基础服务和执行流程。</li>
<li>DXE派遣器：负责调度执行DXE驱动，初始化系统设备。</li>
</ul>
</li>
<li>每个DXE驱动是一个独立的模块，DXE驱动之间通过Protocol通信。Protocol是一个特殊的结构体，每个Protocol对应一个GUID。</li>
<li>当所有的Driver都执行完后，系统完成初始化，调用BDS的入口函数，进入到BDS阶段。</li>
</ul>
<h3 id="4-bds阶段boot-device-selection">
  4. BDS阶段(Boot Device Selection)
  <a class="anchor" href="#4-bds%e9%98%b6%e6%ae%b5boot-device-selection">#</a>
</h3>
<ul>
<li>主要功能是执行启动策略：
<ul>
<li>初始化控制台设备。</li>
<li>加载必要的设备驱动。</li>
<li>根据系统设置加载和执行启动项。</li>
</ul>
</li>
<li>用户选中的某个启动项后，OS Loader启动，系统进入TSL阶段。</li>
</ul>
<h3 id="5-tsl阶段transient-system-load">
  5. TSL阶段（Transient System Load）
  <a class="anchor" href="#5-tsl%e9%98%b6%e6%ae%b5transient-system-load">#</a>
</h3>
<ul>
<li>TSL是OS Loader执行的第一阶段，在这个阶段OS Loader作为一个UEFI应用程序运行，系统资源仍由UEFI内核控制。</li>
<li>当启动服务的ExitBootServices服务被调用后，系统进入Run Time阶段。</li>
<li>TSL阶段被称为临时系统，它存在的目的就是为操作系统加载器准备执行环境。</li>
</ul>
<h3 id="6-rt阶段run-time">
  6. RT阶段（Run Time)
  <a class="anchor" href="#6-rt%e9%98%b6%e6%ae%b5run-time">#</a>
</h3>
<ul>
<li>系统进入RT阶段后，系统的控制权从UEFI内核转交到OS Loader手中，UEFI占用的各种资源被回收到OS Loader，仅有UEFI运行时服务保留给OS Loader和OS使用。</li>
<li>随着OS Loader的执行，OS最终取得对系统的控制权。</li>
</ul>
<h3 id="7-al阶段after-life">
  7. AL阶段（After Life）
  <a class="anchor" href="#7-al%e9%98%b6%e6%ae%b5after-life">#</a>
</h3>
<ul>
<li>在RT阶段，如果系统遇到灾难性错误，固件需要提供错误处理和灾难恢复机制。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/c%E8%AF%AD%E8%A8%80/GCC%E5%92%8CMakefile/">GCC和Makefile</a>
    </h2>
    
  <h5>2023-02-18</h5>



  

  
  <div>
    
      <a href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a>
  </div>
  




    <p><h2 id="gcc">
  GCC
  <a class="anchor" href="#gcc">#</a>
</h2>
<h3 id="gcc编译">
  GCC编译
  <a class="anchor" href="#gcc%e7%bc%96%e8%af%91">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#预处理</span>
</span></span><span style="display:flex;"><span>gcc -E -o hello.i hello.c
</span></span><span style="display:flex;"><span><span style="color:#75715e">#编译(包含预处理)</span>
</span></span><span style="display:flex;"><span>gcc -S -o hello.s hello.i
</span></span><span style="display:flex;"><span><span style="color:#75715e">#汇编(包含预处理和编译)</span>
</span></span><span style="display:flex;"><span>gcc -c -o hello.o hello.s
</span></span><span style="display:flex;"><span><span style="color:#75715e">#链接(包含上面的步骤)</span>
</span></span><span style="display:flex;"><span>gcc -o hello hello.o
</span></span></code></pre></div><h4 id="预处理">
  预处理
  <a class="anchor" href="#%e9%a2%84%e5%a4%84%e7%90%86">#</a>
</h4>
<ul>
<li>源文件中以&quot;#&ldquo;开头的命令被称为预处理命令，如&rdquo;#include&quot;、&quot;#define&quot;、&quot;#ifdef&quot;等，预处理是将要包含的文件插入到原文件中，将宏定义展开、根据条件选择要使用的代码，最后将结果输出到一个文件中等待后续处理。</li>
</ul>
<h4 id="编译">
  编译
  <a class="anchor" href="#%e7%bc%96%e8%af%91">#</a>
</h4>
<ul>
<li>编译是将预处理后的文件翻译成汇编代码，用到的工具为cc1。</li>
</ul>
<h4 id="汇编">
  汇编
  <a class="anchor" href="#%e6%b1%87%e7%bc%96">#</a>
</h4>
<ul>
<li>汇编试讲汇编代码翻译成机器码，在linux上一般表现为ELF目标文件（OBJ文件），用到的工具为as。</li>
</ul>
<h4 id="链接">
  链接
  <a class="anchor" href="#%e9%93%be%e6%8e%a5">#</a>
</h4>
<ul>
<li>链接是将生成的OBJ代码和系统库的OBJ文件、库文件链接起来，最终生成了可以在特定平台运行的可执行文件，用到的工具为ld或collect2.</li>
</ul>
<h3 id="常用选项">
  常用选项
  <a class="anchor" href="#%e5%b8%b8%e7%94%a8%e9%80%89%e9%a1%b9">#</a>
</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>-E</td>
<td>预处理</td>
</tr>
<tr>
<td>-c</td>
<td>把预处理、编译、汇编都做的，但是不链接</td>
</tr>
<tr>
<td>-o</td>
<td>指定输出文件</td>
</tr>
<tr>
<td>-I</td>
<td>指定头文件目录</td>
</tr>
<tr>
<td>-L</td>
<td>指定链接时使用库文件的目录</td>
</tr>
<tr>
<td>-l（小L）</td>
<td>指定链接哪一个库文件，如-labc就是链接libabc.so</td>
</tr>
<tr>
<td>-v</td>
<td>显示编译器驱动程序、预处理器、编译器办吧等信息。</td>
</tr>
<tr>
<td>-Wall</td>
<td>打开所有需要注意的警告信息</td>
</tr>
</tbody>
</table>
<pre tabindex="0"><code>#include &lt;xxx&gt; //在标准库的目录开始搜索（包括使用-Idir定义的目录）
#include &#34;xxx&#34; //先从用户的工作目录开始搜索，再搜索标准库目录
</code></pre><h3 id="库">
  库
  <a class="anchor" href="#%e5%ba%93">#</a>
</h3>
<ul>
<li>动态库</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#创建动态链接库</span>
</span></span><span style="display:flex;"><span>gcc -shared -o libsub.so sub.o sub1.o
</span></span><span style="display:flex;"><span><span style="color:#75715e">#使用当前目录下得sub库</span>
</span></span><span style="display:flex;"><span>gcc -o test main.o -lsub -L ./
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#运行时需要指定动态库的位置，可以将libsub.so移动到/lib目录下，或者配置一个环境变量</span>
</span></span><span style="display:flex;"><span>export LD_LIBRARY_PATH<span style="color:#f92672">=</span>$LD_LIBRARY_PATH:/xiaox
</span></span></code></pre></div><ul>
<li>静态库</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#生成静态库</span>
</span></span><span style="display:flex;"><span>ar crs libsub.a sub.o sub2.o
</span></span><span style="display:flex;"><span><span style="color:#75715e">#将静态库打包到程序里</span>
</span></span><span style="display:flex;"><span>gcc -o tet main.o libsub.a
</span></span></code></pre></div><h3 id="命令">
  命令
  <a class="anchor" href="#%e5%91%bd%e4%bb%a4">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#列出头文件目录、库目录(LIBRARY_PATH)等</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;main(){}&#39;</span>| gcc -E -v -
</span></span></code></pre></div><h2 id="makefile">
  Makefile
  <a class="anchor" href="#makefile">#</a>
</h2>
<ul>
<li>格式如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#a6e22e">target </span><span style="color:#f92672">:</span> prerequires1 prerequires2 ...
</span></span><span style="display:flex;"><span>	command1
</span></span><span style="display:flex;"><span>	command2
</span></span><span style="display:flex;"><span>	...
</span></span></code></pre></div><h3 id="变量">
  变量
  <a class="anchor" href="#%e5%8f%98%e9%87%8f">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>A <span style="color:#f92672">:=</span> XXX //立即变量
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> XXX //延时变量，在使用时才生效
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">+=</span> yyy //拼接字符串
</span></span><span style="display:flex;"><span>D <span style="color:#f92672">?=</span> xxx //如果D之前定义过，则此语句无效；如果之前定义值，此语句定义。
</span></span></code></pre></div><h4 id="例">
  例
  <a class="anchor" href="#%e4%be%8b">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>A <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>C<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>C<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">=</span> abc
</span></span><span style="display:flex;"><span>D <span style="color:#f92672">?=</span> weidongshan
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@echo</span> A <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>A<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@echo</span> B <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>B<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@echo</span> D <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>D<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">+=</span> <span style="color:#ae81ff">123</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#结果
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#A = 立即变量定义式就确定，所以A的值为空
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#B = abc 123 延时变量只有在用到时才确定，当执行make时，会解析Makefile里面的所有变量。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#D = weidongshan 因为D在前面没有定义，所以是此值。
</span></span></span></code></pre></div><h3 id="通配符">
  通配符
  <a class="anchor" href="#%e9%80%9a%e9%85%8d%e7%ac%a6">#</a>
</h3>
<ul>
<li><code>*.c</code> 表示所有的.c结尾的文件。</li>
<li><code>$@</code>表示target。</li>
<li><code>$&lt;</code>表示第一个依赖文件。</li>
<li><code>$^</code>表示所有的依赖文件。</li>
</ul>
<h3 id="假想目标phony">
  假想目标.PHONY
  <a class="anchor" href="#%e5%81%87%e6%83%b3%e7%9b%ae%e6%a0%87phony">#</a>
</h3>
<ul>
<li>target并非只要求是文件，也可以是个标记（假想目标），声明要采取的动作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#a6e22e">clean </span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	rm -rf *.o
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY </span><span style="color:#f92672">:</span> clean
</span></span></code></pre></div><h3 id="函数">
  函数
  <a class="anchor" href="#%e5%87%bd%e6%95%b0">#</a>
</h3>
<ul>
<li>foreach</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#75715e">#对于list中的每一个var，执行text的动作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">$(</span>foreach var,list,text<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A <span style="color:#f92672">:=</span> a b c
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>foreach f, <span style="color:#66d9ef">$(</span>A<span style="color:#66d9ef">)</span>, <span style="color:#66d9ef">$(</span>f<span style="color:#66d9ef">)</span>.c<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all </span><span style="color:#f92672">:</span> 
</span></span><span style="display:flex;"><span>	@echo B <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>B<span style="color:#66d9ef">)</span>
</span></span></code></pre></div><ul>
<li>filter/filter-out</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#66d9ef">$(</span>filter pattern...,text<span style="color:#66d9ef">)</span> <span style="color:#75715e"># 在text中取出符合patten格式的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">$(</span>filter-out pattern...,text<span style="color:#66d9ef">)</span> <span style="color:#75715e"># 在text中取出不符合patten格式的值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A <span style="color:#f92672">:=</span> a b c dxx
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>filter %xx, <span style="color:#66d9ef">$(</span>A<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all </span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	@echo <span style="color:#66d9ef">$(</span>B<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#结果为dxx
</span></span></span></code></pre></div><ul>
<li>patsubst</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#75715e">#如果var中的值匹配pattern，就将它替换为replacement
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">$(</span>patsubst pattern, replacement, <span style="color:#66d9ef">$(</span>var<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>files <span style="color:#f92672">:=</span> a.c b.c c.c d.c e.c abc
</span></span><span style="display:flex;"><span>dep_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>patsubst %.c,%.d,<span style="color:#66d9ef">$(</span>files<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">all </span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	@echo dep_files <span style="color:#f92672">=</span> <span style="color:#66d9ef">$(</span>dep_files<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#结果为 dep_files = a.d b.d c.d d.d e.d abc
</span></span></span></code></pre></div><h2 id="头文件依赖">
  头文件依赖
  <a class="anchor" href="#%e5%a4%b4%e6%96%87%e4%bb%b6%e4%be%9d%e8%b5%96">#</a>
</h2>
<ul>
<li>通过命令，自动生成依赖的的头文件，当头文件发生变化时，重新生成对应的文件。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#-M获取c.c依赖的头文件</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#-MF将依赖输出的c.d的文件</span>
</span></span><span style="display:flex;"><span>gcc -M -MF c.d c.c
</span></span></code></pre></div><h4 id="例-1">
  例
  <a class="anchor" href="#%e4%be%8b-1">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span>objs <span style="color:#f92672">=</span> a.o b.o c.o
</span></span><span style="display:flex;"><span>dep_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>patsubst %,.%.d, <span style="color:#66d9ef">$(</span>objs<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>dep_files <span style="color:#f92672">:=</span> <span style="color:#66d9ef">$(</span>wildcard <span style="color:#66d9ef">$(</span>dep_files<span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">test </span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>objs<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	gcc -o test $^
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">%.o </span><span style="color:#f92672">:</span> %.c
</span></span><span style="display:flex;"><span>	gcc -c -o $@ $&lt; -M -MF .$@.d
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">ifneq</span> <span style="color:#960050;background-color:#1e0010">(</span><span style="color:#66d9ef">$(</span>dep_files<span style="color:#66d9ef">)</span><span style="color:#960050;background-color:#1e0010">,)</span>
</span></span><span style="display:flex;"><span>	<span style="color:#960050;background-color:#1e0010">include</span> <span style="color:#66d9ef">$(</span>dep_files<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">endif</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">clean</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>	rm *.o test
</span></span><span style="display:flex;"><span>	rm <span style="color:#66d9ef">$(</span>dep_files<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">.PHONY</span><span style="color:#f92672">:</span> clean
</span></span></code></pre></div>
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/19/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
	    </div>

      <footer class="page-footer">
        
  


 
      </footer>
    </div>

  </main>

</body>
</html>











