<!DOCTYPE html>
<html dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark">

<title>主页 | 小象的blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.e24d94cf619e7e6705439036ee43e77f243d24ac89100b59375379bc4d659d87.css" >
  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" ></script>
<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="小象的blog" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">

    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>小象的blog</span>
  </a>
</h2>


















  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/tags/bios/">
        BIOS
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


  <div class="split-line"></div>
  
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


 
      </div>
    </aside>

    <div class="book-page">
      <div>
	      <header class="book-header">
          
  <div class="flex align-center justify-between">
   <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
  
  <strong>主页</strong>
</div>


  
    <aside class="hidden clearfix">
      <nav>
        




        








        

  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/tags/bios/">
        BIOS
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





      </nav>
      <div class="split-line"></div>
      
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


    </aside>
  
 
        </header>
        
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E6%A1%A5%E6%A8%A1%E5%BC%8F/">桥模式</a>
    </h2>
    
  <h5>2020-10-20</h5>



  

  
  <div>
    
      <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>
  




    <p><ul>
<li>模式定义：将抽象与实现分离，使它们都可以独立地变化。</li>
<li>应用场景：两个非常强的变化维度。</li>
</ul>
<h3 id="案例">
  案例
  <a class="anchor" href="#%e6%a1%88%e4%be%8b">#</a>
</h3>
<p>
  <img src="/img/%e6%a1%a5%e6%a8%a1%e5%bc%8f/1.jpg" alt="场景" /></p>
<ol>
<li>
<p>分析一下，首先会创建1个电脑类，然后创建3个电脑的子类（即电脑的类型），再创建3x3个子类。假设有n种电脑类型，m种电脑品牌，那么产生的类的数量为<strong>1+n+n</strong>x<strong>m</strong>。</p>
</li>
<li>
<p>如果再加一个电脑品牌acer，则需要再添加三个类，即acer台式机、acer笔记本、acer平板。显然这种方式产生的类的数量非常多。</p>
</li>
<li>
<p>此外，这个实现违背了单一职责原则，类中出现了两个变化（电脑类型和品牌）。</p>
</li>
<li>
<p>解决办法：将类型写成一个抽象类，将品牌写成一个抽象类。通过一个&quot;桥&quot;将他们联系起来。</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//品牌类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Brand</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Lenovo</span> <span style="color:#66d9ef">implements</span> Brand<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Apple</span> <span style="color:#66d9ef">implements</span> Brand<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dell</span> <span style="color:#66d9ef">implements</span> Brand<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><hr>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//电脑类
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Computer</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//通过类组合来替代类继承
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">protected</span> Brand brand<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Computer</span><span style="color:#f92672">(</span>Brand brand<span style="color:#f92672">){</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">brand</span><span style="color:#f92672">=</span>brand<span style="color:#f92672">;}</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Desktop</span> <span style="color:#66d9ef">extends</span> Computer<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Desktop</span><span style="color:#f92672">(</span>Brand brand<span style="color:#f92672">){</span><span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>brand<span style="color:#f92672">);}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Laptop</span> <span style="color:#66d9ef">extends</span> Computer<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Laptop</span><span style="color:#f92672">(</span>Brand brand<span style="color:#f92672">){</span><span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>brand<span style="color:#f92672">);}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Pad</span> <span style="color:#66d9ef">extends</span> Computer<span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Pad</span><span style="color:#f92672">(</span>Brand brand<span style="color:#f92672">){</span><span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>brand<span style="color:#f92672">);}</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">info</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><ol start="5">
<li>通过上面的修改，类的数量变成了<strong>1+n+m</strong>。</li>
<li>在这里我理解的抽象是Brand，实现指的是Computer和Computer的子类。</li>
</ol>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/synchronized/">synchronized</a>
    </h2>
    
  <h5>2020-10-13</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><h3 id="轻量级锁">
  轻量级锁
  <a class="anchor" href="#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81">#</a>
</h3>
<ul>
<li>使用场景：如果一个对象虽然有多线程访问，但多线程的访问时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</li>
<li>使用线程的栈中的锁记录充当锁。</li>
<li>轻量级锁对使用者是透明的，即语法仍然是synchronized。</li>
<li>轻量级锁在没有竞争时，每次重入仍需要执行CAS操作。</li>
</ul>
<h3 id="锁膨胀">
  锁膨胀
  <a class="anchor" href="#%e9%94%81%e8%86%a8%e8%83%80">#</a>
</h3>
<ul>
<li>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</li>
</ul>
<h3 id="自旋优化">
  自旋优化
  <a class="anchor" href="#%e8%87%aa%e6%97%8b%e4%bc%98%e5%8c%96">#</a>
</h3>
<ul>
<li>重量级锁竞争的时候，还可以使用自旋来优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</li>
</ul>
<h3 id="偏向锁">
  偏向锁
  <a class="anchor" href="#%e5%81%8f%e5%90%91%e9%94%81">#</a>
</h3>
<ul>
<li>只有在第一次使用CAS将线程ID设置到对象头的Mark Word中，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</li>
<li>调用对象的hashCode()会禁用该对象的偏向锁；当有其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁；调用wait/notify会转化为重量级锁。</li>
<li>批量重偏向：如果对象虽然被多个线程访问，但是没有竞争，这时候偏向了t1的线程的对象仍有机会重新偏向t2，重偏向会重置对象的ThreadID。当撤销偏向锁<strong>阈值超过20次</strong>后，jvm会觉得：我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程。</li>
<li>批量撤销：当撤销偏向锁阈值超过40次后，jvm会觉得：自己确实错了，根本就不应该偏向。于是整个类的所有对象都会变成不可偏向的，新建的对象也是不可偏向的，针对类的优化。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/Monitor/">Monitor</a>
    </h2>
    
  <h5>2020-10-12</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><h3 id="java对象头">
  java对象头
  <a class="anchor" href="#java%e5%af%b9%e8%b1%a1%e5%a4%b4">#</a>
</h3>
<p>32位虚拟机下</p>
<ul>
<li>普通对象</li>
</ul>
<p>
  <img src="/img/Monitor/1.jpg" alt="普通对象" /></p>
<ul>
<li>数组对象</li>
</ul>
<p>
  <img src="/img/Monitor/2.jpg" alt="数组对象" /></p>
<ul>
<li>mark word结构</li>
</ul>
<p>
  <img src="/img/Monitor/3.jpg" alt="mark word结构" /></p>
<ul>
<li>64位虚拟机下mark word结构</li>
</ul>
<p>
  <img src="/img/Monitor/4.jpg" alt="64位虚拟机下mark word结构" /></p>
<h3 id="monitor">
  Monitor
  <a class="anchor" href="#monitor">#</a>
</h3>
<ul>
<li>每个java对象都可以关联一个monitor对象，monitor对象由操作系统提供。如果使用synchronized给对象上锁（重量级）后，该对象对象头的mark word中的数据就会清空（不包括标志位，但标志位会发生改变），然后指向一个monitor对象。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/java%E7%BA%BF%E7%A8%8B%E7%9A%846%E7%A7%8D%E7%8A%B6%E6%80%81/">java线程的6种状态</a>
    </h2>
    
  <h5>2020-10-08</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><ul>
<li>
<p>操作系统层面线程有5种状态</p>
</li>
<li>
<p>在 java中，Thread.State 将线程分为六种状态</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">enum</span> State <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程刚被创建，但是还没调用start方法
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        NEW<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 该状态的线程在jvm中是执行状态，但是在操作系统中可能是在等待其他的资源。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 此状态涵盖了操作系统中的 运行态、就绪态、阻塞态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        RUNNABLE<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 此状态的线程会等待一个monitor lock。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * A thread in the blocked state is waiting for a monitor lock 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * to enter a synchronized block/method or
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * reenter a synchronized block/method after calling Object.wait
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        BLOCKED<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Thread state for a waiting thread.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 以下方法可使线程进入此状态：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 Object.wait with no timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 Thread.join with no timeout 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 LockSupport.park
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 该状态的线程会等待其他线程通过特定的动作唤醒。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        WAITING<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * Thread state for a waiting thread with a specified(特定的) waiting time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 以下方法可使线程进入此状态：
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 Thread.sleep
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 Object.wait with timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 Thread.join with timeout
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 LockSupport.parkNanos
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         * 	 LockSupport.parkUntil
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">         */</span>
</span></span><span style="display:flex;"><span>        TIMED_WAITING<span style="color:#f92672">,</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 线程已经完成了执行，终止了的状态。
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        TERMINATED<span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span></code></pre></div>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/%E5%B9%B6%E5%8F%91%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF/">并发相关信息</a>
    </h2>
    
  <h5>2020-10-08</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><h3 id="thread方法">
  Thread方法
  <a class="anchor" href="#thread%e6%96%b9%e6%b3%95">#</a>
</h3>
<ul>
<li>
<p>sleep：让当前线程休眠n毫秒，休眠时让出cpu的时间片给其他线程。</p>
</li>
<li>
<p>join：等待某个线程运行结束。</p>
</li>
<li>
<p>yield：提示线程调度器让出当前线程对 CPU的使用。</p>
</li>
<li>
<p>interrupt()：打断线程，可能会产生打断标记（看下面的介绍）。</p>
<ul>
<li>可以使用isInterrupted()判断线程是否被打断。</li>
<li>如果线程正在sleep、wait、join会导致被打断的线程抛出InterruptedException，并清除打断标记。</li>
<li>如果打断正在运行的线程，则会设置打断标记。</li>
<li>interrupted()方法能返回打断标记的状态，并将打断标记设置为假。</li>
</ul>
</li>
</ul>
<h3 id="同步">
  同步
  <a class="anchor" href="#%e5%90%8c%e6%ad%a5">#</a>
</h3>
<ul>
<li>同步：需要等待结果返回，才能继续运行就是同步。</li>
<li>异步：不需要等待结果返回，就能继续运行就是异步。</li>
</ul>
<h3 id="常见线程安全类">
  常见线程安全类
  <a class="anchor" href="#%e5%b8%b8%e8%a7%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%b1%bb">#</a>
</h3>
<p>String  Integer  StringBuffer  Random  Vector  Hashtable  java.util.concurrent</p>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/wait%E5%92%8Cnotify/">wait和notify</a>
    </h2>
    
  <h5>2020-10-06</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><ul>
<li>在调用wait方法时，线程必须要持有被调用对象的锁，当调用wait方法之后，线程就会释放掉该对象的锁。</li>
<li>在调用Thread类的sleep方法时，线程是<strong>不会释放掉对象的锁</strong>的。</li>
</ul>
<hr>
<ol>
<li>当调用wait方法时，首先要确保调用了wait方法的线程已经持有了对象的锁。</li>
<li>当调用了wait后，该线程就会释放掉这个对象的锁，然后进入等待状态，该线程进入对象的等待集合中（wait set）。</li>
<li>当线程调用了wait后进入到等待状态时，它就等待其他线程调用相同对象的notify和notifyAll方法来使得自己被唤醒。</li>
<li>调用wait方法的代码片段需要放在一个synchronized块或者被synchronized修饰的方法中。</li>
<li>当调用了对象的notify方法时，它会随机唤醒该对象等待集合中（wait set）的任意一个线程，当某个线程被唤醒后，它就会与其他线程一同竞争对象的锁。</li>
<li>当调用对象的notifyAll方法时，它会唤醒该对象等待集合中（wait set）中所有的线程，这些线程被唤醒后，又会开始竞争对象的锁。</li>
<li>某一时刻，只有唯一的一个线程拥有对象的锁。</li>
</ol>
<h3 id="具体案例">
  具体案例
  <a class="anchor" href="#%e5%85%b7%e4%bd%93%e6%a1%88%e4%be%8b">#</a>
</h3>
<p>Demon对象有一个int类型的属性counter，该值初始为0；
创建四个线程，两个线程对该值增1，两个线程对该值减1；
输出counter每次变化后的结果，要求输出结果为1010101010&hellip;。</p>
<h5 id="包含counter的demon类">
  包含counter的Demon类
  <a class="anchor" href="#%e5%8c%85%e5%90%abcounter%e7%9a%84demon%e7%b1%bb">#</a>
</h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//该对象提供加1和减1的操作
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Demon</span><span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//counter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> counter<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//对方法加锁，当一个线程要调用该方法时，需要先获取该对象的锁
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">inc</span><span style="color:#f92672">(){</span><span style="color:#75715e">//counter加1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">//此处必须使用while而不是if，防止被其他不相关的线程唤醒
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>counter<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                wait<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        counter<span style="color:#f92672">++;</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>counter<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">/*此处必须使用notifyAll，notify会从等待队列中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">        随机选择一个线程唤醒，可能会导致程序一直阻塞*/</span>
</span></span><span style="display:flex;"><span>        notifyAll<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>	<span style="color:#75715e">//counter减1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dec</span><span style="color:#f92672">(){</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span><span style="color:#f92672">(</span>counter<span style="color:#f92672">!=</span><span style="color:#ae81ff">1</span><span style="color:#f92672">){</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                wait<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>InterruptedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
</span></span><span style="display:flex;"><span>                e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>            <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span>        counter<span style="color:#f92672">--;</span>
</span></span><span style="display:flex;"><span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">print</span><span style="color:#f92672">(</span>counter<span style="color:#f92672">);</span>
</span></span><span style="display:flex;"><span>        notifyAll<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">}</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">}</span>
</span></span></code></pre></div><p><strong>关键代码如上，剩余的代码也都比较简单，就省略了。如果你需要所有代码，可以通过<code>ctrl+u</code>查看网页源代码，并使用<code>ctrl+f</code>快捷键搜索&quot;黑魔仙变身&quot;即可找到完整代码。手机需要使用能查看网页源代码的浏览器，如via等。</strong></p>
<!--
//黑魔仙变身
//该对象提供加1和减1的操作
class Demon{
    //counter
    private int counter=0;
	//对方法加锁，当一个线程要调用该方法时，需要先获取该对象的锁
    public synchronized void inc(){//counter加1
        //此处必须使用while而不是if，防止被其他不相关的线程唤醒
        while(counter!=0){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter++;
        System.out.print(counter);
        /*此处必须使用notifyAll，notify会从等待队列中
        随机选择一个线程唤醒，可能会导致程序一直阻塞*/
        notifyAll();
    }
	//counter减1
    public synchronized void dec(){
        while(counter!=1){
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        counter--;
        System.out.print(counter);
        notifyAll();
    }
}
//执行counter++
class IncThread implements Runnable{
    private Demon demon;
    public IncThread(Demon demon){
        this.demon=demon;
    }
    //实现Runnable的run方法
    public void run() {
        for(int i=0;i<30;i++) {
            demon.inc();
        }
    }
}
//执行counter--
class DecThread implements Runnable{
    private Demon demon;
    public DecThread(Demon demon){
        this.demon=demon;
    }
    public void run() {
        for(int i=0;i<30;i++) {
            demon.dec();
        }
    }
}
//测试类
public class test {
    public static void main(String[] args) throws InterruptedException {
        Demon demon=new Demon();
        Thread t1=new Thread(new IncThread(demon));
        Thread t2=new Thread(new IncThread(demon));
        Thread t3=new Thread(new DecThread(demon));
        Thread t4=new Thread(new DecThread(demon));
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
-->
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">垃圾回收器</a>
    </h2>
    
  <h5>2020-09-30</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><p><strong>-XX:+PrintCommandLineFlags</strong>：查看命令行参数（可打印出使用的是哪个垃圾回收器）。</p>
<p>
  <img src="/img/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8/3.jpg" alt="垃圾收集器" /></p>
<h3 id="serial回收器串行回收">
  Serial回收器：串行回收
  <a class="anchor" href="#serial%e5%9b%9e%e6%94%b6%e5%99%a8%e4%b8%b2%e8%a1%8c%e5%9b%9e%e6%94%b6">#</a>
</h3>
<ul>
<li>
<p>Client模式下默认的新生代垃圾收集器。</p>
</li>
<li>
<p>Serial收集器采用复制算法、串行回收和“Stop-The-World”机制的方式执行内存回收。</p>
</li>
<li>
<p>Serial Old-对应的老年代垃圾收集器，同样采用串行回收和“Stop-The-World”机制，只不过内存回收算法使用的是标记-压缩算法。</p>
<ul>
<li>Serial Old是Client模式下默认的老年代的垃圾收集器。</li>
<li>Serial Old在Server模式下主要有两个用途：①与新生代的Parallel Scavenge配合使用；②作为老年代CMS收集器的后备垃圾收集方案。</li>
</ul>
</li>
<li>
<p>这个收集器是一个单线程的收集器，在它进行垃圾收集时，必须停掉其他所有的工作线程，直到它收集结束。</p>
</li>
<li>
<p>-XX:+UseSerialGC：指定新生代Serial，老年代Serial Old GC。</p>
</li>
</ul>
<h3 id="parnew回收器并行回收">
  ParNew回收器：并行回收
  <a class="anchor" href="#parnew%e5%9b%9e%e6%94%b6%e5%99%a8%e5%b9%b6%e8%a1%8c%e5%9b%9e%e6%94%b6">#</a>
</h3>
<ul>
<li>
<p>多线程的Serial。</p>
</li>
<li>
<p>-XX:+UseParNewGC：指定年轻代ParNew，不影响老年代。</p>
</li>
<li>
<p>-XX:ParallelGCThreads：限制线程数量，默认开启与cpu数据相同的线程数。</p>
</li>
</ul>
<h3 id="parallel-scavenge回收器吞吐量优先">
  Parallel Scavenge回收器：吞吐量优先
  <a class="anchor" href="#parallel-scavenge%e5%9b%9e%e6%94%b6%e5%99%a8%e5%90%9e%e5%90%90%e9%87%8f%e4%bc%98%e5%85%88">#</a>
</h3>
<ul>
<li>
<p>同样采用并行回收、复制算法、STW机制。</p>
</li>
<li>
<p>Parallel Scavenge收集器的目标是达到一个可控的吞吐量，它也被称为吞吐量优先的垃圾收集器。</p>
</li>
<li>
<p>自适应调节机制也是Parallel Scavenge与ParNew的一个重要区别。</p>
</li>
<li>
<p>高吞吐量可以高效的利用cpu时间，尽快的完成程序的运算任务。<strong>主要用于在后台运算而不需要太多交互的任务</strong>。</p>
</li>
<li>
<p>应用场景：执行批量处理、订单处理、工资支付、科学计算的应用程序。</p>
</li>
<li>
<p>Parallel Old：老年代垃圾收集器，采用标记-压缩算法、并行回收、STW机制。</p>
</li>
<li>
<p>-XX:+UseParallelGC：手动指定年轻代使用Parallel；-XX:+UserParallelOldGC：手动指定老年代。这两个参数，当指定一个，另一个也会被开启。</p>
</li>
<li>
<p>-XX:ParallelGCThreads：设置年轻代并行的线程数。</p>
</li>
<li>
<p>-XX:+UseAdaptiveSizePolicy：设置Parallel收集器具有自适应调节策列。</p>
</li>
</ul>
<h3 id="cms回收器低延迟concurrent-mark-sweep">
  CMS回收器：低延迟(Concurrent-Mark-Sweep)
  <a class="anchor" href="#cms%e5%9b%9e%e6%94%b6%e5%99%a8%e4%bd%8e%e5%bb%b6%e8%bf%9fconcurrent-mark-sweep">#</a>
</h3>
<ul>
<li>
<p>HotSpot虚拟机中第一款真正意义上的并发收集器，实现了让垃圾收集线程与用户线程同时执行。</p>
</li>
<li>
<p>采用标记清除算法，也会导致stw。</p>
</li>
<li>
<p>运行过程：</p>
<ul>
<li>初始标记：仅标记GC Roots能直接关联到的对象。速度很快，需要stw。</li>
<li>并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但不需要停顿用户线程。</li>
<li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的stw一般会比初始标记稍长一些。</li>
<li>并发清除：清理标记阶段判断已经死亡的对象，释放内存空间。这个阶段可与用户线程并发。</li>
</ul>
</li>
</ul>
<p>
  <img src="/img/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8/2.jpg" alt="cms" /></p>
<ul>
<li>
<p>由于在垃圾收集阶段用户线程仍在执行，所以在<strong>CMS回收过程中，要保证应用程序线程有足够的内存可用</strong>。因此，CMS收集器不能像别的收集器一样等到老年代几乎完全填满了才进行垃圾回收，而是在堆内存达到某一个阈值时，便开始进行回收。当CMS运行期间，内存无法满足程序要求，这时虚拟机会启用预备方案：临时使用Serial Old进行垃圾回收。</p>
</li>
<li>
<p>CMS采用标记-清除算法，只能采用空闲列表进行内存分配。</p>
</li>
<li>
<p>优点：低延迟，并发收集。</p>
</li>
<li>
<p>缺点：产生内存碎片；对cpu资源非常敏感，因为占用了一部分线程，会导致吞吐量降低；无法处理浮动垃圾（并发标记阶段如果产生新的垃圾，cms无法对这些垃圾进行标记，会导致这些垃圾无法及时的被回收）。</p>
</li>
<li>
<p>-XX:+UseConcMarkSweepGC：手动指定使用CMS收集器。</p>
</li>
</ul>
<h3 id="g1回收器区域分代化">
  G1回收器：区域分代化
  <a class="anchor" href="#g1%e5%9b%9e%e6%94%b6%e5%99%a8%e5%8c%ba%e5%9f%9f%e5%88%86%e4%bb%a3%e5%8c%96">#</a>
</h3>
<ul>
<li>
<p>-XX:+UseG1GC：启用G1。</p>
</li>
<li>
<p>目标：延迟可控的情况下获取尽可能高的吞吐量。</p>
<ul>
<li>G1是一个并行回收器，它把堆内存分割为很多不相关的区域。使用不同的region来表示Eden区、幸存者0区、幸存者1区、老年代等。</li>
<li>G1有计划的避免在java堆中进行全区域的垃圾回收，G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。</li>
<li>由于这种方式的侧重点在于回收垃圾最大量的区间，所以给G1取一个名字：垃圾优先（Garbage First）。</li>
</ul>
</li>
<li>
<p>优点：</p>
<ul>
<li>并行性：G1在回收期间，可以多个GC线程同时工作。此时用户线程stw。</li>
<li>并发性：G1部分工作能与用户线程同时执行。</li>
<li>分代收集：G1仍属于分代型垃圾收集器。但是不再要求整个Eden、年轻代、或者老年代都是连续的，也不再坚持固定大小和数量。它同时兼顾年轻代和老年代。</li>
<li>空间整合：内存是以region为基本单位的。region之间是复制算法，整体上看可以看作是标记-压缩算法。可以避免产生内存碎片。</li>
<li>可预测的时间停顿模型：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li>
</ul>
</li>
<li>
<p>-XX:MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</p>
</li>
<li>
<p>Remembered Set：一个对象可能被不同区域region所引用。当有其它region指向本region时，记录其他region的引用。</p>
</li>
<li>
<p>G1垃圾回收的过程</p>
<ul>
<li>年轻代GC：①扫描根（包含RSet）；②更新RSet；③处理RSet；④复制对象；⑤处理引用。</li>
<li>并发标记过程：①初始标记（标记根节点直接可达的对象，会触发一次年轻代GC）；②根区域扫描（扫描survivor区能直达老年代的对象并标记被引用的对象）；③并发标记（若发现一个region区域全是垃圾，则直接回收）；④再次标记；⑤独占清理；⑥并发清理阶段。</li>
<li>混合回收：回收整个Yong Region和一部分Old Region。</li>
<li>如果上述方式不能正常工作，就会触发Full GC。</li>
</ul>
</li>
</ul>
<p>
  <img src="/img/%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8/4.jpg" alt="现状" /></p>
<!--
|  垃圾收集器  |    分类    |    作用位置    |      使用算法      |     特点     |               适用场景               |
| :----------: | :--------: | :------------: | :----------------: | :----------: | :----------------------------------: |
|    Serial    |    串行    |     新生代     |      复制算法      | 响应速度优先 |         单cpu的client模式下          |
|    ParNew    |    并行    |     新生代     |      复制算法      | 响应速度优先 |  多cpu环境Server模式下与CMS配合使用  |
|   Parallel   |    并行    |     新生代     |      复制算法      |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|  Serial Old  |    串行    |     老年代     |   标记-压缩算法    | 响应速度优先 |          单cpu的client模式           |
| Parallel Old |    并行    |     老年代     |   标记-压缩算法    |  吞吐量优先  | 适用于后台运算而不需要太多交互的场景 |
|     CMS      |    并发    |     老年代     |   标记-清除算法    | 响应速度优先 |        适用于互联网或B/S业务         |
|      G1      | 并发、并行 | 新生代、老年代 | 标记压缩、复制算法 | 响应速度优先 |            面向服务端应用            |
-->
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/javase/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">垃圾回收相关概念</a>
    </h2>
    
  <h5>2020-09-29</h5>



  

  
  <div>
    
      <a href="/tags/java/">java</a>
  </div>
  




    <p><h3 id="systemgc的理解">
  System.gc()的理解
  <a class="anchor" href="#systemgc%e7%9a%84%e7%90%86%e8%a7%a3">#</a>
</h3>
<ul>
<li>在默认情况下，通过System.gc()或者Runtime.getRuntime().gc()的调用会显示触发Full GC，但是该方法可能不是立刻就执行。</li>
</ul>
<h3 id="内存溢出">
  内存溢出
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba">#</a>
</h3>
<ul>
<li>产生原因：没有空闲内存，并且垃圾收集器也无法提供更多内存。</li>
</ul>
<h3 id="内存泄漏">
  内存泄漏
  <a class="anchor" href="#%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f">#</a>
</h3>
<ul>
<li>严格定义：对象不再被程序使用了，但是GC又不能回收他们的情况（仍然存在引用链）。</li>
<li>宽泛定义：一些不太好的实践会导致对象的生命周期变得很长，甚至导致OOM，也叫宽泛意义上的内存泄漏。</li>
</ul>
<h3 id="安全点">
  安全点
  <a class="anchor" href="#%e5%ae%89%e5%85%a8%e7%82%b9">#</a>
</h3>
<ul>
<li>程序执行时并非在所有的地方都能停下来开始GC，只有在特定的位置才能停顿下来开始GC，这些位置称为“安全点”（safepoint）。</li>
<li>如何在GC发生时，检测所有的程序都跑到最近的安全点停顿下来了呢 &ndash;&gt; 主动式中断：设置一个中断标志，各个线程运行到safe point的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。</li>
</ul>
<h3 id="安全区域">
  安全区域
  <a class="anchor" href="#%e5%ae%89%e5%85%a8%e5%8c%ba%e5%9f%9f">#</a>
</h3>
<ul>
<li>指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。</li>
<li>可以应对处于sleep或者blocked状态的线程，这时候线程无法响应jvm的中断请求，“走”到安全点去中断挂起。</li>
<li>当程序运行到safe region的代码时，首先标识已经进入了safe region，如果这段时间发生了gc，jvm会忽略标识为safe region状态的线程。</li>
<li>当线程即将离开safe region时，会检测jvm是否已经完成了gc，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开safe region的信号为止。</li>
</ul>
<h3 id="引用">
  引用
  <a class="anchor" href="#%e5%bc%95%e7%94%a8">#</a>
</h3>
<ul>
<li>
<p><strong>强引用</strong>：类似“Object object=new Object()”这类的引用，只要强引用还存在，就永不回收。</p>
</li>
<li>
<p><strong>软引用</strong>：内存不足才回收。</p>
</li>
<li>
<p><strong>弱引用</strong>：发现即回收。</p>
</li>
<li>
<p><strong>虚引用</strong>：对象回收跟踪。</p>
<ul>
<li>如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</li>
<li>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的get方法来获取对象时，总是null。</li>
<li>为一个对象设置虚引用关联的唯一目的就是能够在这个对象被收集器回收时收到一个系统通知。</li>
<li>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知引用程序对象的回收情况。</li>
<li>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#75715e">//声明强引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Object obj<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//声明软引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>SoftReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> sf<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> SoftReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;(</span><span style="color:#66d9ef">new</span> Object<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//声明弱引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>WeakReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> wr<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> WeakReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;(</span><span style="color:#66d9ef">new</span> Object<span style="color:#f92672">());</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//虚引用
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>Object obj<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> Object<span style="color:#f92672">();</span>
</span></span><span style="display:flex;"><span>ReferenceQueue<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> rq<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> ReferenceQueue<span style="color:#f92672">&lt;&gt;();</span>
</span></span><span style="display:flex;"><span>PhantomReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> pr<span style="color:#f92672">=</span><span style="color:#66d9ef">new</span> PhantomReference<span style="color:#f92672">&lt;&gt;(</span>obj<span style="color:#f92672">,</span>rq<span style="color:#f92672">);</span>
</span></span></code></pre></div><h3 id="评估性能指标">
  评估性能指标
  <a class="anchor" href="#%e8%af%84%e4%bc%b0%e6%80%a7%e8%83%bd%e6%8c%87%e6%a0%87">#</a>
</h3>
<ul>
<li><strong>吞吐量</strong>：运行用户代码时间占总运行时间的比例。</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong>暂停时间</strong>：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率。</li>
<li>内存占用：Java堆区所占的内存大小。</li>
<li>快速：一个对象从诞生到被回收所经历的时间。</li>
</ul>
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item">
        <a href="/posts/" aria-label="First" class="page-link" role="button"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/13/" aria-label="Previous" class="page-link" role="button"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/12/" aria-label="Page 12" class="page-link" role="button">12</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/13/" aria-label="Page 13" class="page-link" role="button">13</a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 14" class="page-link" role="button">14</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/15/" aria-label="Page 15" class="page-link" role="button">15</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/16/" aria-label="Page 16" class="page-link" role="button">16</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/15/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/19/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
	    </div>

      <footer class="page-footer">
        
  


 
      </footer>
    </div>

  </main>

</body>
</html>











