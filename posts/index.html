<!DOCTYPE html>
<html dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta name="theme-color" content="#FFFFFF">
<meta name="color-scheme" content="light dark">

<title>主页 | 小象的blog</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" type="image/x-icon">
<link rel="stylesheet" href="/book.min.e24d94cf619e7e6705439036ee43e77f243d24ac89100b59375379bc4d659d87.css" >
  <script defer src="/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js" ></script>
<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="小象的blog" />
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">

    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><img src="/logo.png" alt="Logo" /><span>小象的blog</span>
  </a>
</h2>


















  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/categories/book/">
        书籍笔记
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


  <div class="split-line"></div>
  
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>9</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


 
      </div>
    </aside>

    <div class="book-page">
      <div>
	      <header class="book-header">
          
  <div class="flex align-center justify-between">
   <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
  
  <strong>主页</strong>
</div>


  
    <aside class="hidden clearfix">
      <nav>
        




        








        

  
<ul>
  
  <li>
    <a href="/posts/">
        主页
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/linux%E5%91%BD%E4%BB%A4/">
        linux命令总结
      </a>
  </li>
  
  <li>
    <a href="/posts/linux/shell%E8%84%9A%E6%9C%AC/">
        shell脚本
      </a>
  </li>
  
  <li>
    <a href="/categories/book/">
        书籍笔记
      </a>
  </li>
  
  <li>
    <a href="/about/">
        关于
      </a>
  </li>
  
</ul>





      </nav>
      <div class="split-line"></div>
      
  
<nav>
  <ul>
  
    
	  
	
  
    
	  
		
		  <li>
			<a href="/tags/bios/"  class="flex justify-between">
			  <span>bios</span>
			  <span>9</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%85%B6%E4%BB%96/"  class="flex justify-between">
			  <span>其他</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/c%E8%AF%AD%E8%A8%80/"  class="flex justify-between">
			  <span>c语言</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/linux/"  class="flex justify-between">
			  <span>linux</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"  class="flex justify-between">
			  <span>信息安全</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"  class="flex justify-between">
			  <span>计算机网络</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/java/"  class="flex justify-between">
			  <span>java</span>
			  <span>53</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/nginx/"  class="flex justify-between">
			  <span>nginx</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"  class="flex justify-between">
			  <span>数据库</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E5%89%8D%E7%AB%AF/"  class="flex justify-between">
			  <span>前端</span>
			  <span>4</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/http/"  class="flex justify-between">
			  <span>http</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/python/"  class="flex justify-between">
			  <span>python</span>
			  <span>6</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/git/"  class="flex justify-between">
			  <span>git</span>
			  <span>1</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"  class="flex justify-between">
			  <span>设计模式</span>
			  <span>10</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"  class="flex justify-between">
			  <span>数据结构</span>
			  <span>7</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"  class="flex justify-between">
			  <span>操作系统</span>
			  <span>5</span>
			</a>
		  </li>
		
		  <li>
			<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"  class="flex justify-between">
			  <span>计算机组成原理</span>
			  <span>1</span>
			</a>
		  </li>
		
      
	
  
  </ul>
</nav>


    </aside>
  
 
        </header>
        
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/PCIe%E9%94%99%E8%AF%AF%E4%B8%8A%E6%8A%A5/">PCIe错误上报</a>
    </h2>
    
  <h5>2024-05-16</h5>



  

  




    <p><ul>
<li>PCIe定义了两种错误报告机制，baseline error reporting capabilities 和advanced error reporting capability（AER）。所有的PCIe设备都要支持baseline error reporting，AER是可选的。</li>
<li>PCIe定义了两种错误，UCE和CE，其中UCE可以进一步分为Fatal UCE和Non-Fatal UCE。</li>
<li>
  <img src="/img/bios/pcie/error_classification.jpg" alt="" /></li>
</ul>
<h3 id="错误检测机制">
  错误检测机制
  <a class="anchor" href="#%e9%94%99%e8%af%af%e6%a3%80%e6%b5%8b%e6%9c%ba%e5%88%b6">#</a>
</h3>
<ul>
<li>
<p>包含三种错误检测机制</p>
<ul>
<li>Completion Status（用来向requester上报错误）</li>
<li>Error Messages（用来向HOST上报错误）</li>
<li>Error Forwarding（data poisoning）</li>
</ul>
</li>
<li>
<p>其中BIOS侧用的比较多的是Error Messages，可以用来向主机报告错误。</p>
</li>
<li>
<p>EP上的Error Messages会被发送到相应的Root Ports。</p>
</li>
<li>
<p>Error Message包括ERR_COR(CE)、ERR_NONFATAL(NON-FATAL UCE)、ERR_FATAL(FATAL UCE)</p>
</li>
</ul>
<h4 id="error-messages">
  Error Messages
  <a class="anchor" href="#error-messages">#</a>
</h4>
<ul>
<li>EP上的Error Messages会被发送到相应的Root Ports。</li>
<li>Error Message包括ERR_COR(CE)、ERR_NONFATAL(NON-FATAL UCE)、ERR_FATAL(FATAL UCE)</li>
</ul>
<hr>
<ul>
<li>
<p>Root Port是一个PCI-PCI Bridge结构，是从PCIe Root Complex出来的PCIe Link。</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/root_port.jpg" alt="" /></p>
</li>
<li>
<p>PCIe配置空间为0~0xFFF，其中0~0xFF为PCI兼容配置空间(PCI-compatible region)，0x40~0xFF会存放Capability结构，PCI Express Capability就位于0x40~0xFF的位置。0x100~0xFFF是PCIe扩展配置空间（PCI Express Extended Configuration Space）。PCI兼容配置空间可以通过传统的IO寄存器和ECAM访问，PCIe扩展配置空间只能通过ECAM访问（PCI Express Enhanced Configuration Access Mechanism）</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/configuration_space_layout.jpg" alt="" /></p>
</li>
<li>
<p>PCI Express Capability的结构如下图所示，所有的PCIe设备都需要支持该Capability，</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/pcie_cap.jpg" alt="" /></p>
</li>
<li>
<p>PCI Express Extended Capability寄存器位于PCI配置空间的0xFF之后，在0x100~0xFFF这段空间。AER寄存器就位于这段空间。</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/aer_cap.jpg" alt="" /></p>
</li>
<li>
<p>往AER的CE MASK寄存器对应BIT写1，可以屏蔽对应CE上报。</p>
</li>
<li>
<p>error messages生成的流程</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/flowchart_err_msg.jpg" alt="" /></p>
</li>
<li>
<p>error messages上报流程</p>
</li>
<li>
<p>
  <img src="/img/bios/pcie/error_msg_control.jpg" alt="" /></p>
</li>
<li>
<p>某些情况下，NON-FATAL 的错误可能是不需要执行任何的恢复动作的，比如软件尝试从一个不存在的设置执行一个读取操作，Completion中的UR Status将会报告一个错误，此时如果软件为Completer额外产生一个ERR_NONFATAL Message，就可能会导致系统运行异常。</p>
</li>
<li>
<p>Advisory Non-Fatal Error cases可以让在产生NON_FATAL ERROR时发送ERR_COR Message。如果需要让Advisory Non-Fatal Error cases处理NON_FATAL ERROR为更严重的情况，可以将该ERR的严重级别设置为FATAL，这种情况下Agent将会以ERR_FATAL发出该错误。
下图描述了ERROR MESSAGES的生成流程。</p>
</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/HEST%E4%B8%8A%E6%8A%A5%E5%BC%80%E5%8F%91%E5%B0%8F%E7%BB%93/">HEST上报开发小结</a>
    </h2>
    
  <h5>2024-01-12</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><h2 id="1-hest表ghescper">
  1. HEST表、GHES、CPER
  <a class="anchor" href="#1-hest%e8%a1%a8ghescper">#</a>
</h2>
<ul>
<li>APEI（ACPI Platform Error Interfaces）：提供了一种将错误信息传递给OS的机制。</li>
<li>APEI包含了四张ACPI表：
<ul>
<li>ERST（Error Record Serialization Table）</li>
<li>BERT（Boot Error Record Table）</li>
<li>HEST（Hardware Error Source Table）</li>
<li>EINJ (Error Injection Table)</li>
</ul>
</li>
<li>HEST用来将系统硬件错误传递给OSPM，HEST表的结构如下：</li>
<li>
  <img src="/img/hest/3.jpg" alt="" /></li>
<li>GHES（Generic Hardware Error Source）通用硬件错误源，GHES是Error Source Structure的一种。除了GHES外，还有其他的一些错误源（IA-32 Architecture Machine Check Exception、PCI Express Root Port AER、PCI Express Device AER Structure）。</li>
<li>GHES的结构如下图，其中比较重要的字段为Error Status Address和Notify。
<ul>
<li>Error Status Address是一个地址，指向了一块大小固定的地址空间，该空间存放上报给OS的错误信息，结构如下图所示。</li>
<li>Notify表示当错误发生时如何上报给OS。（支持的方式包括SCI、Polled等）</li>
</ul>
</li>
<li>
  <img src="/img/hest/4.jpg" alt="" /></li>
<li>CPER（Common Platform Error Record）：上图中的Error Section可以用来存放CPER（详见UEFI_SPEC的 N）。CPER的结构如下图：</li>
<li>
  <img src="/img/hest/5.jpg" alt="" /></li>
<li>可以通过如下流程，将硬件错误上报给OS，流程如下：
<ol>
<li>新增一条GHES，并将此GHES插入到HEST中。保存GHES中申请的地址基址。
<ol>
<li>要求此GHES的Notify Type为Polled。使用Polled后OS会定期去轮询。</li>
</ol>
</li>
<li>创建CPER，将存在Error的物理地址写入到CPER中。</li>
<li>将CPER插入到GHES指向的物理地址中。（此步骤比较难，需要同步修改Generic Error Status Block和Generic Error Data Entry）。</li>
</ol>
</li>
<li>整个流程用到的数据结构的关系如下：</li>
<li>
  <img src="/img/hest/6.jpg" alt="" /></li>
</ul>
<h2 id="2-linux串口配置">
  2. Linux串口配置
  <a class="anchor" href="#2-linux%e4%b8%b2%e5%8f%a3%e9%85%8d%e7%bd%ae">#</a>
</h2>
<ul>
<li>
<p>开启Linux串口可以收集OS的日志，也可以解决OS下BIOS日志显示不全的问题</p>
</li>
<li>
<p>开启步骤如下：</p>
</li>
</ul>
<ol>
<li>编译grub配置文件，在文件末尾添加如下的配置 <code>vim /etc/default/grub </code></li>
</ol>
<pre tabindex="0"><code>GRUB_CMDLINE_LINUX_DEFAULT=&#34;console=tty0 console=ttyS0,115200n8&#34;
GRUB_TERMINAL=serial
GRUB_SERIAL_COMMAND=&#34;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&#34;
</code></pre><ol start="2">
<li>执行如下命令生成grub配置文件。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>grub2-mkconfig  -o /boot/efi/EFI/centos/grub.cfg
</span></span></code></pre></div><h2 id="3-编译linux内核">
  3. 编译Linux内核
  <a class="anchor" href="#3-%e7%bc%96%e8%af%91linux%e5%86%85%e6%a0%b8">#</a>
</h2>
<ul>
<li>在使用CPER上报OS的过程中，发现dmesg一直报错<code>GHES:Failed to read error status block!</code>，后续重新编译Linux内核，才定位到错误。</li>
<li>编译Linux内核流程如下：</li>
</ul>
<ol>
<li>在Github下载最新的Linux内核代码（下载最新的即可，老版本内核代码可能缺少后续更新的某些patch）：</li>
</ol>
<ul>
<li>
  <img src="/img/hest/1.jpg" alt="" /></li>
</ul>
<ol start="2">
<li>将内核代码传到Linux服务器上，并进行解压。</li>
<li>将/boot路径下的config-xxx文件拷贝到内核代码的路径，并重命名为.config。<code>cp  /boot/config-4.18.0-193.el8.x86_64  .config</code></li>
<li>进入Linux内核目录，执行<code>make menuconfig</code>，之后找找有没有自己感兴趣的配置，把它选上后，保存退出。</li>
<li>开始编译Linux内核，执行<code>make -j128</code>，其中-j表示并行编译，可以加快编译速度，可以根据自己CPU的核心数来调整该值的大小。
<ol>
<li>如果出现报错，是因为缺少某些库，可以自己按照报错去搜一下需要安装的软件或者需要注释掉的选项。</li>
</ol>
</li>
<li>当编译完成后，执行<code>make modules_install</code>来安装内核模块。</li>
<li>执行<code>make install</code>安装Linux内核。</li>
<li>更新grub配置，让其重新扫描内核，并从新的Linux内核启动<code>grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg</code></li>
<li>如果以上步骤执行完后，重新启动可以看到grub中新增加了一个刚编译的内核的启动项。</li>
</ol>
<ul>
<li>
  <img src="/img/hest/2.jpg" alt="" /></li>
</ul>
<hr>
<ul>
<li>内核中使用printk来添加打印信息，使用方式如下：</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">//KERN_ERR是打印级别
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printk</span>(KERN_ERR <span style="color:#e6db74">&#34;%s: kpf acpi_hest_get_size(gdata) = 0x%x, data_len = 0x%x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, __func__, <span style="color:#a6e22e">acpi_hest_get_size</span>(gdata), data_len);
</span></span></code></pre></div><ul>
<li>重新编译并安装内核后，使用<code>dmesg -w</code>即可看到添加的打印信息。</li>
</ul>
<h2 id="4-内存">
  4. 内存
  <a class="anchor" href="#4-%e5%86%85%e5%ad%98">#</a>
</h2>
<ul>
<li>DIMM（Double In-line Memory Module）双列内存模组，双列指的是电路板两侧有两列金手指。</li>
<li>SDRAM（Synchronous Dynamic Random Access Memory）：同步动态随机存储器。同步指的是其时钟频率与CPU前端总线的系统时钟频率相同；动态指的是存储阵列需要不断的刷新来保证数据不丢失；随机指的是可以自由指定地址进行数据的读写。</li>
<li>RANK：也叫P-Bank（Physical Bank），P-Bank是一组内存芯片的集合，这个集合的总位宽必须要和CPU的数据位宽相同。
<ul>
<li>每个内存芯片都有自己的位宽（（SDRAM）存储单元容量=位宽，（DDR）存储单元容量=2×位宽），位宽就是每个传输周期提供的数据量。一般一个内存芯片的位宽为8Bit。</li>
<li>只有知道芯片位宽的情况下，才能确定P-BANK的数量。</li>
</ul>
</li>
<li>BANK：内存可以看作是一个表格，指定一个行（Row）和一个列（Column）后，就可以找到所需要的单元格了，这个单元格可以称为<code>存储单元</code>（一个存储单元可以存nbit的数据（n取决于位宽）），这个表格就叫L-BANK（逻辑Bank，也叫BANK）。
<ul>
<li>一个BANK一般会包含多个表格。所以在进行寻址时，需要先确定是哪个BANK，然后在这个选定的L-BANK中选择相应的行和列进行寻址。</li>
</ul>
</li>
<li>内存芯片的容量（存储单元的容量） = 行数 x 列数 x L-BANK的数量。</li>
<li>DDR SDRAM（Double Data Rate SDRAM）：双倍数据流SDRAM。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/%E5%BE%AE%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E7%BB%84%E6%88%90/">微型计算机的组成</a>
    </h2>
    
  <h5>2023-10-09</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>冯●诺伊曼计算机的基本思想：
<ul>
<li>采用二进制形式表示数据和指令，指令由操作码和地址码组成。</li>
<li>将程序和数据存放在存储器中，计算机工作时从存储器取出指令来执行。</li>
<li>指令的执行时顺序的，程序分支由转移指令实现。</li>
<li>计算机由存储器、控制器、运算器、输入设备和输出设备组成。</li>
</ul>
</li>
<li>现代计算机讲5大部件成为了3个硬件子系统：处理器、存储系统、输入输出系统。处理器包括运算器和控制器；存储系统由寄存器、高速缓冲存储器和辅助存储器几个层次组成。输入输出设备统称为外部设备，简称外设或I/O设备。</li>
<li>冯●诺伊曼计算机采用二进制表示数据和指令，指令是控制计算机操作的指令，指令的二进制编码规则形成了指令的代码格式，指令由操作码和地址码组成。指令的操作码表示指令的操作，如加法操作、操作数是参与操作的数据，主要以寄存器或者存储器地址形式指明数据的来源，所以也成为地址码。</li>
<li>程序和数据在执行前需要存放在主存储器中，在执行时才从主存储器进入处理器。现代计算机中，主存储器是字节可寻址的，主存储器的每个存储单元都具有一个地址，保存一个字节的信息。只要指定了地址就能进行存取的方式被称为随机存取。</li>
<li>处理器的主要功能是从主存储器取指令，翻译指令代码的功能（译码），然后执行指令规定的操作。当一条指令执行完后，处理器会自动地去取下一条将要执行的指令，重复上述过程直到整个程序执行完毕。</li>
<li>为了简化各个部件的相互连接，现代计算机使用总线结构。微处理器内集成了控制器、运算器和若干高速存储单元（寄存器）。</li>
<li>存储系统由处理器内部的寄存器、高速缓冲存储器（Cache）、主存储器（即内存）和辅助存储器构成（如磁盘）。</li>
<li>I/O设备指的是输入设备和输出设备（外设），由于各种外设的工作速度、驱动方法差别很大，需要一个I/O接口充当外设和主机间的桥梁。较复杂的I/O接口电路通常制成独立的电路板。</li>
<li>总线用于多个部件的相互连接。系统总线指的是微机系统中，处理器与存储器和I/O设备进行信息交换的公共通道。总线有几十条到上百条信号线，总线信号一般可以分为3组：
<ul>
<li>地址总线：在该组信号线上，处理器单向输出将要访问的主存单元或I/O端口的地址信息。地址线的多少决定了系统能够直接寻址存储器的容量大小和外设端口范围。</li>
<li>数据总线：数据总线的多少决定了一次能够传输数据的位数。处理器进行读操作时，主存或者外设的数据通过该组信号线输入处理器，处理器进行写操作时，处理器的数据通过该组信号线输出到主存或者外设。</li>
<li>控制总线：控制总线用于协调系统中各个部件的操作。各类总线的特点主要取决于控制总线。</li>
</ul>
</li>
<li>中断是处理器正常执行程序的流程被某种原因打断并暂时停止，转向执行事先安排好的一段处理程序（中断处理程序），待处理程序结束后仍返回被中断的指令处继续执行的过程。中断来自处理器内部就是内部中断，也称为异常（Exception）；中断来自外部就是外部中断。例：指令的调试需要利用中断，PC以中断的方式响应键盘输入。</li>
<li>DMA(Direct Memory Access，直接存储器读取)指主存储器和外设间直接的、不通过处理器的高速数据传输方式。</li>
<li>控制芯片组（即多个控制芯片）提供主板上的关键逻辑电路，如主存控制单元、中断控制器、DMA控制器等，控制芯片决定主板的特性，如支持的主存类型和容量、支持的处理器类型。</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/XHCI/">xHCI</a>
    </h2>
    
  <h5>2023-09-14</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>
  <img src="/img/xhci/1.jpg" alt="" /></li>
<li>USB Driver(USBD): 总线驱动，用来枚举USB设备，给USB设备安装Protocol。</li>
<li>Host Controller Driver(xHCD): xHC控制器驱动。</li>
<li>Host Controller (xHC):USB控制器，是一个硬件设备。</li>
<li>USB Device: 包括HUB和Function，比如鼠标、键盘。</li>
</ul>
<h2 id="xhci介绍">
  XHCI介绍
  <a class="anchor" href="#xhci%e4%bb%8b%e7%bb%8d">#</a>
</h2>
<ul>
<li>
<p>xHCI包含三个空间</p>
</li>
<li>
<p>主机配置空间：一般是PCI配置空间。</p>
</li>
<li>
<p>MMIO空间：主要放一些寄存器（Capability Registers、Operational Registers、Runtime Registers和Doorbell Array）。</p>
</li>
<li>
<p>主机内存：主要放一些数据结构，比如Device Context Base Address Array, Device Contexts, Transfer Ring等。</p>
</li>
<li>
<p>
  <img src="/img/xhci/2.jpg" alt="" /></p>
</li>
<li>
<p>xHCI支持的传输类型：Isochronous（等时传输）、Interrupt（中断传输）、Control（控制传输）、Bulk（批量传输）。</p>
</li>
<li>
<p>Capability Register：这些值作为Host Controller Driver的参数。</p>
</li>
<li>
<p>Runtime和Operational Registers指定主机控制器配置和运行变化状态。系统软件通过该寄存器来控制和监控主机控制器的Operational状态。</p>
</li>
<li>
<p>xHCI Extended Capabilities说明了xHC实现的一些可选特性。</p>
</li>
<li>
<p>Doorbell Array：最多支持256个Doorbell寄存器的数组，每个Doorbell寄存器都向系统软件提供了一种机制，用于通知xHC是否有域槽位或者Endpoint相关的工作要执行。Doorbell寄存器的DB Target字段表示按下门铃的原因。Doorbell寄存器0被主机控制器用域Command Ring管理。</p>
</li>
<li>
<p>Device Slot 表示USB设备的多个XHCI数据结构。每个设备由Device Context BaseAddress Array中的一个元素、Doorbell Array register中的一个寄存器和设备的Device Context组成。Slot ID用于标识特定的Device Slot。</p>
</li>
<li>
<p>Command Ring：软件使用Command Ring将Command传递给xHC。</p>
</li>
<li>
<p>Event Ring：xHC使用Event Ring将Command Completion和Asynchronous event传递给软件。</p>
</li>
<li>
<p>Transfer Ring：软件使用Transfer Ring为Endpoint安排工作。Transfer Ring是一个循环队列（队列中每个元素都是是Transfer Descriptor（TD）），每个TD定义了一个或多个数据Buffer。</p>
</li>
</ul>
<h2 id="xhci数据结构">
  XHCI数据结构
  <a class="anchor" href="#xhci%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">#</a>
</h2>
<h3 id="device-context-base-address-array">
  Device Context Base Address Array
  <a class="anchor" href="#device-context-base-address-array">#</a>
</h3>
<ul>
<li>Device Context Base Address Array (DCBAA)是一个指针数组，数组的每个元素都指向了一个Device Context数据结构。数组最多255个元素。</li>
<li>DCBAA的数组下标就是SLOT ID。</li>
<li>当检测到插入了一个USB设备后：1. 软件初始化一个Device Context数据结构；2. 从xHC获取一个Slot ID；3. 将此Device Context的指针插入到DCBAA的SLOT ID的位置。</li>
</ul>
<h3 id="device-context">
  Device Context
  <a class="anchor" href="#device-context">#</a>
</h3>
<ul>
<li>Device Context用来记录设备的配置和状态信息。</li>
<li>Device Context由32个数据结构组成，第一个数据结构是Slot Context，剩余的数据结构是Endpoint Context。</li>
<li>在枚举USB设备时，软件创建一个Device Context数据结构并初始化为0，在执行了Address Device命令后将该数据结构的所属权传递给xHC。在执行了Disable Slot命令后，xHC会失去该数据结构的所属权。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _DEVICE_CONTEXT {
</span></span><span style="display:flex;"><span>  SLOT_CONTEXT        Slot;
</span></span><span style="display:flex;"><span>  ENDPOINT_CONTEXT    EP[<span style="color:#ae81ff">31</span>];
</span></span><span style="display:flex;"><span>} DEVICE_CONTEXT;
</span></span></code></pre></div><h3 id="slot-context">
  Slot Context
  <a class="anchor" href="#slot-context">#</a>
</h3>
<ul>
<li>Slot Context提供了control、state、addressing和电源管理。</li>
<li></li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> _SLOT_CONTEXT {
</span></span><span style="display:flex;"><span>  UINT32    RouteString    : <span style="color:#ae81ff">20</span>;
</span></span><span style="display:flex;"><span>  UINT32    Speed          : <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ1         : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  UINT32    MTT            : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  UINT32    Hub            : <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  UINT32    ContextEntries : <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UINT32    MaxExitLatency : <span style="color:#ae81ff">16</span>;
</span></span><span style="display:flex;"><span>  UINT32    RootHubPortNum : <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  UINT32    PortNum        : <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UINT32    TTHubSlotId    : <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  UINT32    TTPortNum      : <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  UINT32    TTT            : <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ2         : <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span>  UINT32    InterTarget    : <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UINT32    DeviceAddress  : <span style="color:#ae81ff">8</span>;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ3         : <span style="color:#ae81ff">19</span>;
</span></span><span style="display:flex;"><span>  UINT32    SlotState      : <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ4;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ5;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ6;
</span></span><span style="display:flex;"><span>  UINT32    RsvdZ7;
</span></span><span style="display:flex;"><span>} SLOT_CONTEXT;
</span></span></code></pre></div><h3 id="endpoint-context">
  Endpoint Context
  <a class="anchor" href="#endpoint-context">#</a>
</h3>
<ul>
<li>Endpoint Context数据结构定义了特定的USB Endpoint的配置和状态。Endpoint Context字段包含了Endpoint相关的type、control、state和带宽信息。这些信息由USB设备提供。Endpoint Context还定义了一个TR Dequeue 指定字段，通常提供了一个指向了与此pipe关联的Transfer Ring。</li>
</ul>
<h3 id="rings">
  Rings
  <a class="anchor" href="#rings">#</a>
</h3>
<ul>
<li>Ring是一个循环队列，xHC使用三种类型的Ring：
<ul>
<li>Command Ring：（每个XHC一个）软件使用Command Ring将命令发送给xHC。</li>
<li>Event Ring：（每个中断一个）xHC使用Event Ring将命令状态、结果传递给软件。</li>
<li>Transfer Ring：（每个Endpoint或Stream一个）Transfer Ring被用来在内存和设备Endpoint之间传输数据。</li>
</ul>
</li>
</ul>
<h2 id="command接口">
  Command接口
  <a class="anchor" href="#command%e6%8e%a5%e5%8f%a3">#</a>
</h2>
<ul>
<li>为了管理xHC和连接到xHC的设备，xHC提供了一个Command Ring接口，一个Command Ring上的项目被称为CD（Command Descriptor）。</li>
<li>所有命令都会在Event Ring上生成一个命令完成事件，该事件用于报告命令完成状态。</li>
<li>xHCI 命令集合</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>No Op</td>
<td>测试TRB Ring机制</td>
</tr>
<tr>
<td>Enable Slot</td>
<td>返回设备的Slot  ID并将设备Slot状态从Disabled改为Default</td>
</tr>
<tr>
<td>Disable Slot</td>
<td>将Device Slot从其他任何状态改为Disabled状态</td>
</tr>
<tr>
<td>Address Device</td>
<td>启用Default Control Endpoint，（可选）向USB设备发出SET_ADDRESS命令并将Device Slot设置为Addressed状态</td>
</tr>
<tr>
<td>Configure Endpoint</td>
<td>启用或者禁用设备的Enpoint</td>
</tr>
<tr>
<td>Evaluate Context</td>
<td>告知xHC软件已经修改了选定的Context参数</td>
</tr>
<tr>
<td>Reset Endpoint</td>
<td>复位Endpoint，该命令用于将一个halted endpoint恢复</td>
</tr>
<tr>
<td>Stop Endpoint</td>
<td>停止Endpoint</td>
</tr>
<tr>
<td>Set TR Dequeue Pointer</td>
<td>更新一个启用的endpoint的Transfer Ring Dequeue</td>
</tr>
<tr>
<td>Reset Device</td>
<td>复位Device Slot，此命令用于在复位一个USB设备时同步Device Slot的状态</td>
</tr>
</tbody>
</table>
<h2 id="endpoint">
  Endpoint
  <a class="anchor" href="#endpoint">#</a>
</h2>
<ul>
<li>一个USB设备支持最高31个Endpoints。</li>
</ul>
<h2 id="usb设备初始化">
  USB设备初始化
  <a class="anchor" href="#usb%e8%ae%be%e5%a4%87%e5%88%9d%e5%a7%8b%e5%8c%96">#</a>
</h2>
<ul>
<li>下面是一个连到ROOT HUB的USB设备初始化的流程：
<ol>
<li>当检测到一个USB设备连接后，xHC会将CCS和CSC置为1，并生成一个端口变更事件。</li>
<li>收到端口状态变更事件后，软件根据Port ID字段来确认是哪个Port生成的事件。</li>
<li>软件读取PORTSC寄存器。 USB3协议的Port尝试进入Enabled状态，连接的USB设备进入为<strong>Default</strong>状态。</li>
<li>软件通过Enable Slot命令来从xHC获取设备的slot，XHC会返回一个SLOT ID。Enable Slot执行成功后，Device Slot会进入<strong>Enabled</strong>状态。</li>
<li>获取到设备的slot后，软件初始化此slot关联的数据结构。
<ol>
<li>分配Input Context数据结构。</li>
<li>将Input Context中的Input Control Context的A0和A1标志位置为1。</li>
<li>初始化Input Slot Context数据结构，主要是设置Root Hub Port Number、Route String和Context Entries。</li>
<li>为Default Control Endpoint初始化Transfer Ring。</li>
<li>初始化Input Default Control Endpoint 0 Context，主要是设置EP type = Control、Max Packet Size等信息。</li>
<li>分配Output Device Context 数据结构，从Device Context Base Address Array中选择一个下标（Device Slot Id）用来指向Output Device Context数据结构。</li>
</ol>
</li>
<li>软件使用Address Device命令来给设备分配地址，并启用其Default Control Endpoint。此命令会将Device Slot从Enabled状态置为<strong>Addressed</strong>状态，将USB设备从Default状态置为<strong>Address</strong>状态。</li>
<li>对于LS，HS， 和SS设备，其Default Control Endpoint允许的包大小是固定的，分别为8、64、512字节。对于FS设备，系统软件需要做一些操作来决定最大包大小（此处省略）。</li>
<li>Default Control Endpoint配置完成后，系统软件可以获取到完整的Device Descriptor和Configuration Descriptor，以便将其交给适合的Class Drivers。（软件通过Endpoint 0的GET_DESCRIPTOR请求获取USB描述符）</li>
<li>软件会发出将Contxt Bit 0置为1的Evaluate Context命令，用来告知xHC最大退出延迟的值。此命令同样会修改Output Slot Context Interrupter部分字段的值。</li>
<li>Class Driver会使用Configure EndPoint命令来配置Device Slot，并通过Default Control Endpoint发出USB SET_CONFIGURATION请求来设置USB设备。需要成功设置完这两项操作，才能将USB设备的状态从Address到<strong>Configured</strong>，并将Device SLot从Addressed变更为<strong>Configured</strong>。</li>
<li>如果需要，系统软件可能会配置Alternate Interface。</li>
</ol>
</li>
</ul>
<h3 id="resetting-a-root-hub-port">
  Resetting a Root Hub Port
  <a class="anchor" href="#resetting-a-root-hub-port">#</a>
</h3>
<ul>
<li>复位Root HUb port和连接上的USB设备。如果成功了，就会将PORT的状态设置为Enabled，并且可以获取到设备的Speed（位于PORTSC 的Port Speed）。</li>
<li>无论RESET是否执行成功，Port Reset Change（PRC）标志位都会置为1。如果PRC是从0变为1，则还会生成一个端口变更事件。</li>
</ul>
<h3 id="device-slot-assignment">
  Device Slot Assignment
  <a class="anchor" href="#device-slot-assignment">#</a>
</h3>
<ul>
<li>当执行完RESET PORT后，软件会向XHC发出一个Enable Slot命令（通过Command Ring），</li>
</ul>
<h3 id="device-slot-initialization">
  Device Slot Initialization
  <a class="anchor" href="#device-slot-initialization">#</a>
</h3>
<ul>
<li>一旦USB设备获得了Slot ID，软件会初始化SLOT对应的数据结构，流程如下：
<ol>
<li>初始化Input Context Data 数据结构，将所有字段初始化为0。</li>
<li></li>
</ol>
</li>
</ul>
<h2 id="描述符">
  描述符
  <a class="anchor" href="#%e6%8f%8f%e8%bf%b0%e7%ac%a6">#</a>
</h2>
<h3 id="设备描述符">
  设备描述符
  <a class="anchor" href="#%e8%ae%be%e5%a4%87%e6%8f%8f%e8%bf%b0%e7%ac%a6">#</a>
</h3>
<ul>
<li>设备描述符用于表示USB设备的一般信息，如制造商ID、产品序列号等。</li>
<li>设备上电时，主机USB系统软件读取设备描述符的前8字节，得到endpoint所支持的最大数据包长度，后续控制传输就使用此值进行工作。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  UINT8     Length; <span style="color:#75715e">//描述符字节长度0X12
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     DescriptorType; <span style="color:#75715e">//描述符的类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT16    BcdUSB; <span style="color:#75715e">//USB设备支持的协议版本号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     DeviceClass;    <span style="color:#75715e">//设备类代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     DeviceSubClass; <span style="color:#75715e">//子类代码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     DeviceProtocol; <span style="color:#75715e">//协议码
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     MaxPacketSize0; <span style="color:#75715e">//断点0的最大包长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT16    IdVendor;   <span style="color:#75715e">//厂商ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT16    IdProduct;  <span style="color:#75715e">//产品ID
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT16    BcdDevice;  <span style="color:#75715e">//设备发行号
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     StrManufacturer;    <span style="color:#75715e">//厂商信息的字符串描述符索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     StrProduct; <span style="color:#75715e">//产品信息的字符串描述符索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     StrSerialNumber;    <span style="color:#75715e">//设备序列号信息的字符串描述符索引值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  UINT8     NumConfigurations;  <span style="color:#75715e">//配置描述符数目
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} USB_DEVICE_DESCRIPTOR;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">案例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">Device Descriptor	
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bLength :	0x0012
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bDescriptorType :	0x0001
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bcdUSB :	0x0320  - Spec# = 03.20
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bDeviceClass :	0x00    - Defined at Interface level
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bDeviceSubClass :	0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bDeviceProtocol :	0x00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bMaxEP0Size :	0x09    - 9 bytes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">idVendor :	0x0B95  - &#34;ASIX Electronics Corp.&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">idProduct :	0x1790  - &#34;AX88179 Gigabit Ethernet&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bcdDevice :	0x0200  - Device# = 02.00
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">iManufacturer :	0x01    - &#34;ASIX&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">iProduct :	0x02    - &#34;AX88179A&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">iSerialNumber :	0x03    - &#34;00F30573&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">bNumConfigurations :	0x03
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">------------------------------------------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">*/</span>
</span></span></code></pre></div>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/bios/%E4%BA%8B%E4%BB%B6/">事件</a>
    </h2>
    
  <h5>2023-07-25</h5>



  

  
  <div>
    
      <a href="/tags/bios/">bios</a>
  </div>
  




    <p><ul>
<li>UEFI的所有异步操作需要通过事件来完成。</li>
</ul>
<h2 id="事件函数">
  事件函数
  <a class="anchor" href="#%e4%ba%8b%e4%bb%b6%e5%87%bd%e6%95%b0">#</a>
</h2>
<h3 id="waitforevent-等待事件发生">
  WaitForEvent 等待事件发生
  <a class="anchor" href="#waitforevent-%e7%ad%89%e5%be%85%e4%ba%8b%e4%bb%b6%e5%8f%91%e7%94%9f">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           The event indicated by Index was signaled.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_INVALID_PARAMETER 1. NumberOfEvents is 0; 2. The event indicated by Index is of type EVT_NOTIFY_SIGNAL.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_UNSUPPORTED       The current TPL is not TPL_APPLICATION.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_WAIT_FOR_EVENT)(
</span></span><span style="display:flex;"><span>  IN  UINTN                    NumberOfEvents,  <span style="color:#75715e">//event数组的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_EVENT                <span style="color:#f92672">*</span>Event,  <span style="color:#75715e">//event数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT UINTN                    <span style="color:#f92672">*</span>Index   <span style="color:#75715e">//返回触发事件的下标
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><ul>
<li>WaitForEvent是<strong>阻塞操作</strong>，直到Event数组内任一事件被触发或者事件导致错误出现时，WaitForEvent才返回。</li>
<li>事件触发后返回index，并将事件重置为非触发状态。</li>
<li>EVT_NOTIFY_SIGNAL类型的事件似乎不能用WaitForEvent。</li>
</ul>
<h3 id="createevent-创建事件">
  CreateEvent 创建事件
  <a class="anchor" href="#createevent-%e5%88%9b%e5%bb%ba%e4%ba%8b%e4%bb%b6">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           The event structure was created.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_CREATE_EVENT)(
</span></span><span style="display:flex;"><span>  IN  UINT32                       Type,    <span style="color:#75715e">//事件类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_TPL                      NotifyTpl,   <span style="color:#75715e">//Notification函数的优先级
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  EFI_EVENT_NOTIFY             NotifyFunction,  <span style="color:#75715e">//Notification函数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  VOID                         <span style="color:#f92672">*</span>NotifyContext,  <span style="color:#75715e">//传给Notification函数的参数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT EFI_EVENT                    <span style="color:#f92672">*</span>Event   <span style="color:#75715e">//生成的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><h4 id="事件类型">
  事件类型
  <a class="anchor" href="#%e4%ba%8b%e4%bb%b6%e7%b1%bb%e5%9e%8b">#</a>
</h4>
<ul>
<li>事件类型可以是一种或多种基本类型的组合。常用的事件类型如下：</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>特征</th>
</tr>
</thead>
<tbody>
<tr>
<td>EVT_TIMER</td>
<td>定时器事件，没有Notification函数，生成事件后需要调用setTimer服务设置时钟属性。事件可以通过SetTimer设置等待事件、到期后通过SignalEvent触发、通过WaitForEvent等待事件触发、通过CheckEvent检查事件</td>
</tr>
<tr>
<td>EVT_NOTIFY_WAIT</td>
<td>有一个Notification函数，当调用CheckEvent或WaitForEvent时，Notifyication函数会被放到待执行队列</td>
</tr>
<tr>
<td>EVT_NOTIFY_SIGNAL</td>
<td>有一个Notification函数，当前事件通过SignalEvent被触发时，这个Notification函数会被放到待执行队列</td>
</tr>
<tr>
<td>0X00000000</td>
<td>没有Notification函数，事件可以通过signalevent触发、waitforevent等待事件被触发、checkevent检查状态</td>
</tr>
</tbody>
</table>
<ul>
<li>还有两种特殊的事件
<ul>
<li>EVT_SIGNAL_EXIT_BOOT_SERVICES：当ExitBootServices被执行时，事件被触发。</li>
<li>EVT_SIGNAL_VIRTUAL_ADDRESS_CHANGE：当SetVirtualAddressMap被调用时触发此类型的事件。</li>
</ul>
</li>
</ul>
<h4 id="优先级">
  优先级
  <a class="anchor" href="#%e4%bc%98%e5%85%88%e7%ba%a7">#</a>
</h4>
<ul>
<li>有四个预定义的优先级</li>
</ul>
<table>
<thead>
<tr>
<th>优先级</th>
<th>用法</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>TPL_APPLICATION</td>
<td>优先级最低，当程序运行在此级别时，任务队列中没有任何处于就绪状态的Notification函数</td>
<td>下列安徽念书运行在此级别ExitBootServices()、WaitForEvent()等</td>
</tr>
<tr>
<td>TPL_CALLBACK</td>
<td>比较耗时的操作通常在这个优先级</td>
<td>Serial I/O Protocol、UnloadImage</td>
</tr>
<tr>
<td>TPL_NOTIFY</td>
<td>运行在这个级别的程序不允许阻塞，大部分Event的Notification函数允许在这个级别</td>
<td>Memory Allocation Services、HII Protocols</td>
</tr>
<tr>
<td>TPL_HIGH_LEVEL</td>
<td>UEFI内核全局变量的修改允许在这个级别</td>
<td>SignalEvent、stall</td>
</tr>
</tbody>
</table>
<h4 id="notification函数">
  Notification函数
  <a class="anchor" href="#notification%e5%87%bd%e6%95%b0">#</a>
</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">VOID</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_EVENT_NOTIFY)(
</span></span><span style="display:flex;"><span>  IN  EFI_EVENT                Event,   <span style="color:#75715e">//拥有此函数的事件
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  VOID                     <span style="color:#f92672">*</span>Context <span style="color:#75715e">//上下文指针，在CreateEvent设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><ul>
<li>根据上面的事件类型可知，EVT_NOTIFY_WAIT的函数会在等待事件的过程中调用，而EVT_NOTIFY_SIGNAL的Notification函数会在SignalEvent调用。</li>
</ul>
<h3 id="createeventex">
  CreateEventEx
  <a class="anchor" href="#createeventex">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           The event structure was created.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_INVALID_PARAMETER One or more parameters are invalid.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_OUT_OF_RESOURCES  The event could not be allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_CREATE_EVENT_EX)(
</span></span><span style="display:flex;"><span>  IN       UINT32                 Type,
</span></span><span style="display:flex;"><span>  IN       EFI_TPL                NotifyTpl,
</span></span><span style="display:flex;"><span>  IN       EFI_EVENT_NOTIFY       NotifyFunction OPTIONAL,
</span></span><span style="display:flex;"><span>  IN CONST VOID                   <span style="color:#f92672">*</span>NotifyContext OPTIONAL,
</span></span><span style="display:flex;"><span>  IN CONST EFI_GUID               <span style="color:#f92672">*</span>EventGroup    OPTIONAL,  <span style="color:#75715e">//事件组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  OUT      EFI_EVENT              <span style="color:#f92672">*</span>Event
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><ul>
<li>CreateEventEx用于生成事件并将事件加入事件组。当事件组中的任意事件被触发后，组中的所有事件都会被触发，进而组内所有的Notification函数都会被加入待执行队列，组内优先级最高的Notification函数会被先执行。</li>
<li>存在四个预定义的Event组：
<ul>
<li>EFI_EVENT_GROUP_EXIT_BOOT_SERVICES：当执行ExitBootServices触发组内所有的事件。</li>
<li>EFI_EVENT_GROUP_VIRTUAL_ADDRESS_CHANGE：当执行SetVirtualAddressMap触发组内所有的Event。</li>
<li>EFI_EVENT_GROUP_MEMORY_MAP_CHANGE：Memory Map改变时触发组内所有的Event。</li>
<li>EFI_EVENT_GROUP_READY_TO_BOOT：Boot Manager加载并且执行一个启动项时触发组内所有的Event。</li>
</ul>
</li>
</ul>
<h3 id="checkevent-检查事件状态">
  CheckEvent 检查事件状态
  <a class="anchor" href="#checkevent-%e6%a3%80%e6%9f%a5%e4%ba%8b%e4%bb%b6%e7%8a%b6%e6%80%81">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           事件是触发态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_NOT_READY         事件是非触发态
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_INVALID_PARAMETER 事件类型是EVT_NOTIFY_SIGNAL
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_CHECK_EVENT)(
</span></span><span style="display:flex;"><span>  IN EFI_EVENT                Event
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><h3 id="signalevent-触发事件">
  SignalEvent 触发事件
  <a class="anchor" href="#signalevent-%e8%a7%a6%e5%8f%91%e4%ba%8b%e4%bb%b6">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_SIGNAL_EVENT)(
</span></span><span style="display:flex;"><span>  IN  EFI_EVENT                Event
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><ul>
<li>将事件设置为触发态。如果该事件在一个组中，则将族中所有的事件设置为触发态。</li>
</ul>
<h3 id="closeevent-关闭事件">
  CloseEvent 关闭事件
  <a class="anchor" href="#closeevent-%e5%85%b3%e9%97%ad%e4%ba%8b%e4%bb%b6">#</a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_CLOSE_EVENT)(
</span></span><span style="display:flex;"><span>  IN EFI_EVENT                Event
</span></span><span style="display:flex;"><span>  );
</span></span></code></pre></div><h3 id="settimer">
  SetTimer
  <a class="anchor" href="#settimer">#</a>
</h3>
<ul>
<li>EVT_TIMER是一类特殊的事件，可以通过SetTimer服务设置定时器属性。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_SUCCESS           The event has been set to be signaled at the requested time.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">  @retval EFI_INVALID_PARAMETER Event or Type is not valid.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">**/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">EFI_STATUS</span>
</span></span><span style="display:flex;"><span>(EFIAPI <span style="color:#f92672">*</span>EFI_SET_TIMER)(
</span></span><span style="display:flex;"><span>  IN  EFI_EVENT                Event,
</span></span><span style="display:flex;"><span>  IN  EFI_TIMER_DELAY          Type,    <span style="color:#75715e">//定时器类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  IN  UINT64                   TriggerTime  <span style="color:#75715e">//过期事件，100ns为一个单位
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  );
</span></span></code></pre></div><ul>
<li>定时器类型如下：</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>TimerCancel</td>
<td>取消定时器触发</td>
</tr>
<tr>
<td>TimerPeriodic</td>
<td>重复型定时器</td>
</tr>
<tr>
<td>TimerRelative</td>
<td>一次性定时器</td>
</tr>
</tbody>
</table>
<ul>
<li>如果Type为TimerPeriodic并且TriggerTIme是0，则定时器每个时钟滴答触发一次。</li>
<li>生成定时器事件包含两步：
<ol>
<li>通过CreateEvent生成一个EVT_TIMER事件</li>
<li>通过SetTimer设置这个定时器事件的属性。</li>
</ol>
</li>
</ul>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/%E5%85%B6%E4%BB%96/vscode/">Vscode</a>
    </h2>
    
  <h5>2023-06-14</h5>



  

  
  <div>
    
      <a href="/tags/%E5%85%B6%E4%BB%96/">其他</a>
  </div>
  




    <p><ul>
<li>vscode c语言中数组和指针关系紧密，DEBUG一个c程序后，在WATCH那一栏添加下面这行即可看到数组的数据</li>
</ul>
<pre tabindex="0"><code>*(char(*)[4096])bitmap
</code></pre>
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/">C语言练习</a>
    </h2>
    
  <h5>2023-06-09</h5>



  

  
  <div>
    
      <a href="/tags/c%E8%AF%AD%E8%A8%80/">c语言</a>
  </div>
  




    <p><ul>
<li>练习程序。</li>
</ul>
        <a href="/posts/c%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80%E7%BB%83%E4%B9%A0/">查看更多</a>
      
    </p>
  </article>
  
  <article class="markdown book-post">
    <h2>
      <a href="/posts/linux/ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">Ext4文件系统</a>
    </h2>
    
  <h5>2023-05-12</h5>



  

  
  <div>
    
      <a href="/tags/linux/">linux</a>
  </div>
  




    <p><ul>
<li>一个ext4文件系统被分割为多个block groups，block groups的大小在<code>sb.s_blocks_per_group</code>块中指定。</li>
<li>默认情况下一个块的大小是4KiB，此时每个block group会包含32768个块，即一个group的大小为128MiB。</li>
<li>ext4中块是最小的分配单位。</li>
<li>ext4文件系统采用小端模式，数值的低字节存储在低地址处，高字节存储在高地址处。比如数“12 34 56 78”，小端存放的形式如下“78 56 34 12”。大端存放的形式为“12 34 56 78”。</li>
<li>一个标准的block group布局如下（并非所有的块都是此布局）：</li>
<li>
  <img src="/img/linux/ext4/1.jpg" alt="" /></li>
<li>centos7下使用dumpe2fs获取到的ext4文件系统的信息</li>
<li>
  <img src="/img/linux/ext4/1.2.jpg" alt="" /></li>
<li>
  <img src="/img/linux/ext4/1.1.jpg" alt="" /></li>
<li>ext4会保留一些inode作为特殊用途，如下：</li>
<li>
  <img src="/img/linux/ext4/2.jpg" alt="" /></li>
</ul>
<h2 id="ext4文件系统">
  ext4文件系统
  <a class="anchor" href="#ext4%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f">#</a>
</h2>
<h3 id="目录">
  目录
  <a class="anchor" href="#%e7%9b%ae%e5%bd%95">#</a>
</h3>
<ul>
<li>目录也是文件，目录有对应的inode和data blocks，目录的data block中存放多个ext4_dir_entry_2，结构如下：</li>
<li>
  <img src="/img/linux/ext4/3.jpg" alt="" /></li>
<li>文件类型可以取的值如下：</li>
<li>
  <img src="/img/linux/ext4/4.jpg" alt="" /></li>
<li>案例
<ul>
<li><code>0D000000</code> <code>1000</code> <code>05</code> <code>01</code>  <code>6673746162</code>  <code>000000</code></li>
<li>第一块表示inode号</li>
<li>第二块表示此结构体长度为0x0010，即16，因为ext4采用小端存放，所以高位在高地址，低位在低地址。</li>
<li>第三块表示文件名为5字节</li>
<li>第四块表示文件类型为普通文件</li>
<li>第五块是文件名，对应fstab，f的ascii是0x66，s的是0x73，t是0x75。</li>
<li>最后一块是填充位，结构体大小必须是最大对其数的整数倍。</li>
</ul>
</li>
</ul>
        <a href="/posts/linux/ext4%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/">查看更多</a>
      
    </p>
  </article>
  

  
    <ul class="pagination pagination-default">
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="First" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;&laquo;</span></a>
      </li>
      <li class="page-item disabled">
        <a aria-disabled="true" aria-label="Previous" class="page-link" role="button" tabindex="-1"><span aria-hidden="true">&laquo;</span></a>
      </li>
      <li class="page-item active">
        <a aria-current="page" aria-label="Page 1" class="page-link" role="button">1</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Page 2" class="page-link" role="button">2</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/3/" aria-label="Page 3" class="page-link" role="button">3</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/4/" aria-label="Page 4" class="page-link" role="button">4</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/5/" aria-label="Page 5" class="page-link" role="button">5</a>
      </li>
      <li class="page-item">
        <a href="/posts/page/2/" aria-label="Next" class="page-link" role="button"><span aria-hidden="true">&raquo;</span></a>
      </li>
      <li class="page-item">
        <a href="/posts/page/19/" aria-label="Last" class="page-link" role="button"><span aria-hidden="true">&raquo;&raquo;</span></a>
      </li>
    </ul>
 
	    </div>

      <footer class="page-footer">
        
  


 
      </footer>
    </div>

  </main>

</body>
</html>











